/*
Navicat MySQL Data Transfer

Source Server         : MySQL
Source Server Version : 50720
Source Host           : localhost:3306
Source Database       : blog

Target Server Type    : MYSQL
Target Server Version : 50720
File Encoding         : 65001

Date: 2018-09-28 10:22:02
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `aid` char(32) NOT NULL,
  `title` varchar(100) NOT NULL,
  `content` text NOT NULL,
  `tag` varchar(50) DEFAULT NULL,
  `person_classify` varchar(100) DEFAULT NULL,
  `type` char(6) DEFAULT NULL,
  `all_classify` varchar(100) DEFAULT NULL,
  `status` varchar(10) NOT NULL,
  `uid` char(32) NOT NULL,
  `time` varchar(20) NOT NULL,
  `readCount` int(11) NOT NULL,
  `commentCount` int(11) NOT NULL,
  `username` varchar(50) NOT NULL,
  PRIMARY KEY (`aid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('12bc042ec4fe4f00a437d60ce7960cd1', 'elasticsearch 深入 —— 分析器执行顺序与Mapping自定义分析器配置', '<p>默认分析器</p><p><br/></p><p>虽然我们可以在字段层级指定分析器， 但是如果该层级没有指定任何的分析器，那么我们如何能确定这个字段使用的是哪个分析器呢？</p><p><br/></p><p>分析器可以从三个层面进行定义：按字段（per-field）、按索引（per-index）或全局缺省（global default）。Elasticsearch 会按照以下顺序依次处理，直到它找到能够使用的分析器。索引时的顺序如下：</p><p><br/></p><p>字段映射里定义的 analyzer ，否则</p><p><span style=\"white-space:pre\">	</span>索引设置中名为 default 的分析器，默认为</p><p><span style=\"white-space:pre\">	</span>standard 标准分析器</p><p>在搜索时，顺序有些许不同：</p><p><br/></p><p>查询自己定义的 analyzer ，否则</p><p><span style=\"white-space:pre\">	</span>字段映射里定义的 analyzer ，否则</p><p><span style=\"white-space:pre\">	</span>索引设置中名为 default 的分析器，默认为</p><p><span style=\"white-space:pre\">	</span>standard 标准分析器</p><p>有时，在索引时和搜索时使用不同的分析器是合理的。 我们可能要想为同义词建索引（例如，所有 quick出现的地方，同时也为 fast 、 rapid 和 speedy 创建索引）。但在搜索时，我们不需要搜索所有的同义词，取而代之的是寻找用户输入的单词是否是 quick 、 fast 、 rapid 或 speedy 。</p><p><br/></p><p>为了区分，Elasticsearch 也支持一个可选的 search_analyzer 映射，它仅会应用于搜索时（ analyzer 还用于索引时）。还有一个等价的 default_search 映射，用以指定索引层的默认配置。</p><p><br/></p><p>如果考虑到这些额外参数，一个搜索时的 完整 顺序会是下面这样：</p><p><br/></p><p>查询自己定义的 analyzer ，否则</p><p><br/></p><p>---------------------</p><p><br/></p><p>本文来自 gmHappy 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/ctwy291314/article/details/81391514?utm_source=copy&nbsp;</p><p><br/></p>', '数据库', '', '翻译', '数据库', '已发布', 'a1097602c3174132952e56ef8840d7cb', '2018年09月26日 15:06:59', '226', '0', 'YANG');
INSERT INTO `article` VALUES ('1e3447634da04baabdd972ac5f9e879d', 'Android：关于 Intent组件的那些小事（介绍、使用方法等）', '<h1 style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 8px 0px 16px; font-size: 28px; color: rgb(79, 79, 79); line-height: 36px; word-break: break-all; font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-ligatures: common-ligatures; white-space: normal; background-color: rgb(255, 255, 255);\">目录</h1><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin-top: 0px; margin-bottom: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all; font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-ligatures: common-ligatures; white-space: normal; background-color: rgb(255, 255, 255);\"><img src=\"http://upload-images.jianshu.io/upload_images/944365-914a66e9767f673e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"示意图\"/></p><hr/><h1 style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 8px 0px 16px; font-size: 28px; color: rgb(79, 79, 79); line-height: 36px; word-break: break-all; font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-ligatures: common-ligatures; white-space: normal; background-color: rgb(255, 255, 255);\"><a style=\"box-sizing: border-box; outline: 0px; color: rgb(78, 161, 219); cursor: pointer; background-color: transparent; word-break: break-all;\"></a><a target=\"_blank\" style=\"box-sizing: border-box; outline: 0px; color: rgb(78, 161, 219); cursor: pointer; background-color: transparent; word-break: break-all;\"></a>1. 定义</h1><p style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin-top: 0px; margin-bottom: 16px; color: rgb(79, 79, 79); line-height: 26px; text-align: justify; word-break: break-all; font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-ligatures: common-ligatures; white-space: normal; background-color: rgb(255, 255, 255);\">意图，描述的是应用的动作 &amp; 其对应的数据</p><hr/><h1 style=\"box-sizing: border-box; outline: 0px; padding: 0px; margin: 8px 0px 16px; font-size: 28px; color: rgb(79, 79, 79); line-height: 36px; word-break: break-all; font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-ligatures: common-ligatures; white-space: normal; background-color: rgb(255, 255, 255);\"><a style=\"box-sizing: border-box; outline: 0px; color: rgb(78, 161, 219); cursor: pointer; background-color: transparent; word-break: break-all;\"></a><a target=\"_blank\" style=\"box-sizing: border-box; outline: 0px; color: rgb(78, 161, 219); cursor: pointer; background-color: transparent; word-break: break-all;\"></a>2. 作用</h1><ol style=\"list-style-type: none;\" class=\" list-paddingleft-2\"><li><p>指定当前组件要完成的动作</p></li><li><p>在<span class=\"Apple-converted-space\">&nbsp;</span><code style=\"box-sizing: border-box; outline: 0px; font-family: Consolas, Inconsolata, Courier, monospace; padding: 2px 4px; line-height: 22px; color: rgb(199, 37, 78); background-color: rgb(249, 242, 244); border-radius: 2px; word-break: break-all;\">Android</code><span class=\"Apple-converted-space\">&nbsp;</span>不同组件间 传递数据</p></li></ol><h1>2. 作用</h1><ol class=\" list-paddingleft-2\"><li><p>指定当前组件要完成的动作</p></li><li><p>在 <code>Android</code> 不同组件间 传递数据</p></li></ol><blockquote><p><code>Activity</code>、<code>Service</code>、<code>BroadcastReceiver</code>之间的通信载体 = <code>Intent</code></p></blockquote><p>下面，将根据<code>Intent</code>的作用，详细讲解其使用方法</p><hr/><h1><a></a><a target=\"_blank\"></a>3. 使用1：指定当前组件要完成的动作</h1><p>该使用 分为显式 &amp; 隐式意图：</p><h3><a></a><a target=\"_blank\"></a>3.1 显式意图</h3><ul class=\" list-paddingleft-2\"><li><p>特点<br/>明确指定需启动的组件名</p></li></ul><blockquote><p>即 显式<code>Intent</code>不需 解析<code>Intent</code> 则可直接启动目标组件</p></blockquote><ul class=\" list-paddingleft-2\"><li><p>具体使用<br/>明确指定组件名的方式：调用<code>Intent</code>的构造方法、<code>Intent.setComponent（）</code>、<code>Intent.setClass（）</code></p></li><li><p>实例说明</p></li></ul><pre class=\"prettyprint\">//&nbsp;使FirstActivity启动SecondActivity（通过按钮）\r\nmybutton.setOnClickListener(new&nbsp;OnClickListener()&nbsp;{\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;onClick(View&nbsp;v)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;1.&nbsp;实例化显式Intent&nbsp;&amp;&nbsp;通过构造函数接收2个参数\r\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;参数1&nbsp;=&nbsp;Context：启动活动的上下文，一般为当前Activity\r\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;参数2&nbsp;=&nbsp;Class：是指定要启动的目标活动\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Intent&nbsp;intent&nbsp;=&nbsp;new&nbsp;Intent(FirstActivity.this,SecondActivity.class);\r\n&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;2.&nbsp;通过Activity类的startActivity（）执行该意图操作（接收一个Intent对象）\r\n&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;将构建好的Intent对象传入该方法就可启动目标Activity\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startActivity&nbsp;(intent);\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n});123456789101112131415</pre><h3><a></a><a target=\"_blank\"></a>3.2 隐式意图</h3><ul class=\" list-paddingleft-2\"><li><p>特点<br/>无明确指定需启动的组件名，但 <strong>指定了需启动组件需满足的条件</strong></p></li></ul><blockquote><p>即 隐式<code>Intent</code>需 解析<code>Intent</code> ，才可启动目标组件</p></blockquote><ul class=\" list-paddingleft-2\"><li><p>具体使用<br/>通过 <code>AndroidManifest.xml</code>文件下的<code>&lt;Activity&gt;</code>标签下的<code>&lt;intent -filter&gt;</code> 声明 需 匹配的条件</p></li></ul><blockquote><p>一个<code>&lt;Activity&gt;</code>标签下可以有多组&lt;intent -filter&gt;，只需匹配其中1组即可</p></blockquote><ul class=\" list-paddingleft-2\"><li><p>详细说明<br/>声明条件含：动作（<code>Action</code>）、类型（<code>Category</code>）、数据（<code>Data</code>）</p></li></ul><p><img src=\"http://upload-images.jianshu.io/upload_images/944365-4ecf6131261c63e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"示意图\"/></p><ul class=\" list-paddingleft-2\"><li><p>实例说明</p></li></ul><pre class=\"prettyprint\">//&nbsp;使FirstActivity启动SecondActivity（通过按钮）\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mybutton.setOnClickListener(new&nbsp;OnClickListener()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;onClick(View&nbsp;v)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;1.&nbsp;实例化1个隐式Intent对象，并指定action参数\r\n	Intent&nbsp;intent&nbsp;=&nbsp;new&nbsp;Intent(&quot;android.intent.action.ALL_APPS&quot;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;2.&nbsp;调用Intent中的addCategory（）来添加一个category\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;注：每个Intent中只能指定1个action，但却能指定多个category\r\n&nbsp;&nbsp;intent.addCategory(&quot;com.example.intent_test.MY_CATEGORY&quot;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startActivity&nbsp;(intent);\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n});\r\n\r\n//&nbsp;为使SecondActivity能继续响应该Intent\r\n//&nbsp;我们需在AndroidManifest.xml文件下的&lt;Activity&gt;标签下配置&lt;intent&nbsp;-filter&gt;的内容\r\n\r\n&lt;intent-filter&nbsp;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;action&nbsp;android:name=&quot;android.intent.action.ALL_APPS&quot;/&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;category&nbsp;android:name=&quot;android.intent.category.DEFAULT&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/category&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;category&nbsp;android:name=&quot;com.example.intent_test.MY_CATEGORY&quot;/&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/intent-filter&gt;12345678910111213141516171819202122</pre><hr/><h1><a></a><a target=\"_blank\"></a>4. 使用2：不同组件间 传递数据</h1><h3><a></a><a target=\"_blank\"></a>4.1 使用方法</h3><p><code>putExtra（）</code>、<code>Bundle</code>方式</p><h3><a></a><a target=\"_blank\"></a>4.2 可传递的数据类型</h3><p>a. &nbsp;8种基本数据类型（<code>boolean byte char short int long float double</code>）、<code>String</code><br/>b. <code>Intent</code>、<code>Bundle</code><br/>c. <code>Serializable</code>对象、<code>Parcelable</code>及其对应数组、<code>CharSequence</code> 类型<br/>d. <code>ArrayList</code>，泛型参数类型为：<code>&lt;Integer&gt;</code>、<code>&lt;? Extends Parcelable&gt;</code>、<code>&lt;Charsequence&gt;</code>、<code>&lt;String&gt;</code></p><h3><a></a><a target=\"_blank\"></a>4.3 具体使用</h3><p>在当前<code>Activity</code>把要传递的数据暂存在<code>Intent</code>中、在新启动的<code>Activity</code>中取出Intent中的数据</p><ul class=\" list-paddingleft-2\"><li><p>方法1：putExtra（）</p></li></ul><p>---------------------\r\n\r\n本文来自 Carson_Ho 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/carson_ho/article/details/82767978?utm_source=copy&nbsp;</p><p><br/></p>', 'Android,Intent', 'Android,Java', '转载', '后端', '已发布', 'f7fc09d439f34fecaf747db52d7ba396', '2018年09月27日 14:36:52', '82', '14', 'yangming');
INSERT INTO `article` VALUES ('281d3b206f2c4b79a71fdfe1ccf7e66e', '如何开发一款游戏：游戏开发流程及所需工具', '<p style=\"font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;letter-spacing:1.5px;\">游戏作为娱乐生活的一个方面，参与其中的人越来越多，而大部分参与其中的人都是以玩家的身份。</p><p style=\"font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;letter-spacing:1.5px;\">他们热爱一款游戏，或是被游戏的故事情节、炫丽的场景、动听的音乐所艳羡，亦或是被游戏中角色扮演、炫酷的技能、有趣的任务所吸引，然而他们中的大多数可能并不了解如此一款好玩的游戏是如何打造出来的。</p><p style=\"font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;letter-spacing:1.5px;\">对于想来这个行业尝试的新人们，先对游戏开发制作有个整体的了解也是非常必要的。</p><p style=\"font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;letter-spacing:1.5px;\">接下来我将从几个方面来分别进行阐述。</p><h3 style=\"font-size: 18px; color: rgb(240, 150, 28); line-height: 1.75em; letter-spacing: 1.5px;\"><a></a>基础知识</h3><p style=\"font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;letter-spacing:1.5px;\">游戏，说白了就是一个程序，这个程序或在 PC 上或在移动设备上运行，玩家通过与这个程序交互来达到娱乐性的目的。我们先了解一下游戏中用到的各种引擎以及游戏相关术语。</p><h4 style=\"color: rgb(240, 150, 28); line-height: 1.75em; letter-spacing: 1.5px;\">游戏引擎</h4><p style=\"font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;letter-spacing:1.5px;\">游戏引擎是游戏研发的主程序接口，它为开发者提供了各种开发游戏的的工具，即可编辑游戏系统和实时图像系统的核心组件，其目的就在于让开发者可以快速的做出游戏而不必从零开始。</p><p style=\"font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;letter-spacing:1.5px;\">游戏引擎包含渲染引擎、物理引擎、碰撞检测系统、网络引擎、音效引擎、脚本引擎、动画及场景管理等。</p><ul class=\" list-paddingleft-2\" style=\"margin-left:8px;\"><li><p style=\"font-size:15px;color:rgb(85,85,85);line-height:1.75em;letter-spacing:1.5px;\">渲染引擎：是对游戏中的对象和场景起到渲染的效果，游戏中的角色都是通过渲染引擎将它的模型、动画、光影、特效等所有效果实时计算出来并展示到屏幕；</p></li><li><p style=\"font-size:15px;color:rgb(85,85,85);line-height:1.75em;letter-spacing:1.5px;\">物理引擎：让对象运动遵循特定的规律，比如当角色跳起的时候，系统内定的重力值将决定它弹跳的高度及下落的速率；</p></li><li><p style=\"font-size:15px;color:rgb(85,85,85);line-height:1.75em;letter-spacing:1.5px;\">碰撞检测系统：可以探测各物体的边缘，当两个 3D 物体在一起的时候，系统可以防止它们相互穿过；</p></li><li><p style=\"font-size:15px;color:rgb(85,85,85);line-height:1.75em;letter-spacing:1.5px;\">网络引擎：是负责玩家与设备间的通信，处理来自键盘、鼠标及其它外设信号。若游戏联网，它也用来管理客户端与服务器间的通信；</p></li><li><p style=\"font-size:15px;color:rgb(85,85,85);line-height:1.75em;letter-spacing:1.5px;\">Lua 引擎：是 Lua 的服务器引擎，lua 是一种轻量级的嵌入式脚本语言，在网游开发中应用广泛。</p></li></ul><p style=\"font-size:15px;color:rgb(85,85,85);line-height:1.75em;margin-left:8px;letter-spacing:1.5px;\">总的来说，一个游戏是引擎和资源组成的，资源包括图象、声音、动画等，游戏引擎就像一个发动机，控制着游戏的运行，它按游戏设计规则依次调用游戏资源。</p><h4 style=\"color: rgb(240, 150, 28); line-height: 1.75em; letter-spacing: 1.5px;\">游戏名词</h4><ul class=\" list-paddingleft-2\" style=\"margin-left:8px;\"><li><p style=\"line-height:1.75em;\"><span style=\"color:rgb(85,85,85);font-size:15px;\">CD-key：游戏的序列号或防盗密码；</span></p></li><li><p style=\"line-height:1.75em;\"><span style=\"color:rgb(85,85,85);font-size:15px;\">BugFree：测试管理平台，是一款基于 Web 的开源错误追踪工具；</span></p></li><li><p style=\"line-height:1.75em;\"><span style=\"color:rgb(85,85,85);font-size:15px;\">Ping：从客户端发送数据到服务器到接收到服务器反馈数据的时间，以 ms 计，若 Ping 值高会感觉延迟；</span></p></li><li><p style=\"line-height:1.75em;\"><span style=\"color:rgb(85,85,85);font-size:15px;\">Proxy Server：代理服务器，代理网络用户去取得网络信息；</span></p></li><li><p style=\"line-height:1.75em;\"><span style=\"color:rgb(85,85,85);font-size:15px;\">PU：付费用户；</span></p></li><li><p style=\"line-height:1.75em;\"><span style=\"color:rgb(85,85,85);font-size:15px;\">RU：注册用户；</span></p></li><li><p style=\"line-height:1.75em;\"><span style=\"color:rgb(85,85,85);font-size:15px;\">AU：活跃用户；</span></p></li><li><p style=\"line-height:1.75em;\"><span style=\"color:rgb(85,85,85);font-size:15px;\">DAU：平均每日活跃用户；</span></p></li></ul><p>---------------------\r\n\r\n本文来自 GitChat技术杂谈 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/GitChat/article/details/78957555?utm_source=copy&nbsp;</p><p><br/></p>', '游戏,开发', '游戏开发', '原创', '游戏开发', '已发布', 'a3c904ef7cc44272adfb49094a5822a4', '2018年09月26日 20:40:46', '46', '0', 'wolaile');
INSERT INTO `article` VALUES ('282faa0502004632802baaa8d7198e6e', 'java编程思想学习笔记（更新中）', '<h1>一、对象</h1><h2><a></a><a target=\"_blank\"></a>1.1用引用操纵对象</h2><p>每种编程语言都有自己操纵内存中元素的方式。你是直接操纵对象还是间接操纵呢？C和C++中，用指针来操纵对象。<br/>尽管Java把一切都当成对象，但操纵的标识符实际上是对象的一个“引用”。可以把这样的情景假想成用“遥控器”（引用）来操纵“电视机”（对象）。<br/>即使没有电视机，遥控器也可以独立存在。也就是说，你拥有一个引用，并不一定需要有一个对象与它相关联。因此，如果想操纵一个句子或词，可以创建一个String引用：String s; &nbsp; 注意，这里的s只是一个引用，并非对象。安全的做法就是在创建一个引用的同时对其进行初始化。String s=“abcde”; 或者String s=new String(“abcde”);前者首先在栈中创建一个引用变量s，然后查看栈中是否存在“abced”，如果没有，则将“abcde”存放进栈，并让引用变量s指向它；如果有，则直接让s指向它即可；后者是java中标准的对象创建方式，其创建的对象将直接放置到堆中，每调用一次就会创建一个新的对象。</p><h2><a></a><a target=\"_blank\"></a>1.2必须有你创建所有的对象</h2><h3><a></a><a target=\"_blank\"></a>1.2.1存储到什么地方</h3><p>程序运行时，对象怎么进行放置安排的呢？特别是内存如何分配的？有5个不同的地方可以存储数据：<br/>1）寄存器。最快的存储区，位于处理器内部。数量有限，故它根据需求分配。<br/>2）堆栈。位于RAM。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。创建程序时，系统必须知道存储在堆栈中的所有数据的生命周期，以便上下移动堆栈指针。这一约束限制了程序的灵活性。<br/>3）堆。一种通用内存池，用于存放所有java对象。相比堆栈，它编译器不需要知道存储的数据在堆里的生命周期。灵活性强。当需要一个对象时，只需用new写一行简单的代码，当执行这行代码时，胡自动在堆里进行存储分配。但为这种灵活性符出的代价是，用堆进行存储分配和清理可能比堆栈更费时。<br/>4）常量存储。常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会改变。<br/>5）非RAM存储。如果数据完全存活于程序之外，则它可以不受程序任何控制，在程序没有运行时也可以存在。这种存储方式的技巧在于：把对象转换为可以存放在其他媒介上的事物，在需要时，恢复成常规的、基于RAM的对象。</p><h3><a></a><a target=\"_blank\"></a>1.2.2基本类型</h3><p>在程序设计中常用的一系列类型，它们需要特殊对待。之所以特殊对待，是因为new将对象存储在“堆”里，用new创建一个对象——特别是小的、简单的变量，往往不是很有效。因此，对于这些类型，java采取的方法是，不是用new来创建变量，而是创建一个并非是引用的“自动”变量。这个变量直接存储“值”，并置于堆栈中，因此更加高效。</p><h2><a></a><a target=\"_blank\"></a>1.3永远不需要销毁对象</h2><p>事实证明，由new创建的对象，只要你需要，就会一直保留下去。这样便带来一个有趣的问题，如果java让对象继续存在，那么靠什么才能防止这些对象填满内存空间，进而阻塞你的程序？<br/>java有一个垃圾回收器，用来监视用new创建的所有对象，并辨别那些不会再被引用的对象。随后，释放这些对象的内存空间，以便供其他新的对象使用。这样做就消除了“内存泄漏”问题，这是由于程序员忘记释放内存而产生的问题。</p><h2><a></a><a target=\"_blank\"></a>1.6 static关键字</h2><p>通常，你必须创建一个对象，并用它来访问数据或方法。但，当声明一个事物是static时，就意味着这个域或者方法不会与包含它的那个类的任何对象实例关联在一起。所以，即使从未创建某个类的任何对象，也可以调用其static方法或访问其static域。<br/>引用static对象有两种。一种是通过一个对象去定位它，另一种是通过类名直接引用（这对于非静态成员则不行）。<br/>前者例子：</p><pre class=\"prettyprint\">class&nbsp;Test{\r\n		static&nbsp;int&nbsp;i=47;\r\n}\r\nTest&nbsp;t1=new&nbsp;Test();\r\nTest&nbsp;t2=new&nbsp;Test();12345</pre><p>t1.i和t2.i的值均为47。<br/>后者例子：</p><pre class=\"prettyprint\">Test.i++;1</pre><p>t1.i和t2.i的值均为48。</p><p><br/></p>', 'Java,后端,编程思想', 'Java', '原创', '编程语言', '草稿', 'f7fc09d439f34fecaf747db52d7ba396', '2018年09月27日 18:58:14', '4', '0', 'yangming');
INSERT INTO `article` VALUES ('3f2b71ac50a049dda7513248c6a3ed59', 'Python 打造基于有道翻译的命令行翻译工具（命令行爱好者必备）', '<p>之前基于百度写了一篇博文 <a href=\"https://blog.csdn.net/FungLeo/article/details/81045207\" target=\"_blank\">Python 打造基于百度翻译的命令行翻译工具</a>，本来这工具用得挺好的。但是没想到，近期处于不知道啥原因，不能用了。破解人家的接口难免会有这样的情况发生，也不能怪人家百度对吧。</p><p>加上最近工作比较忙，所以也没有去再研究，今天正好有点时间，我就打算重新写一个命令行的翻译工具。想来破解人家的是不对，不如使用人家提供的 <code>Api</code> ，代码清晰简单，使用应该更加长久。</p><h2><a></a><a target=\"_blank\"></a>开发</h2><p>百度提供的接口实在是太挫了，于是看有道翻译的接口，果然很是不错。遂决定基于有道的 <code>Api</code> 来写这个工具。首先到 <a href=\"https://ai.youdao.com/register.s\" target=\"_blank\">https://ai.youdao.com/register.s</a> 进行注册，注册之后创建一个应用，以及创建一个自然语言翻译实例。进行绑定后，拿到 <code>AppId</code> 和 <code>AppKey</code> 两个关键参数。</p><p>然后，我们在本地创建 <code>config.py</code> 文件，录入以下代码：</p><pre class=\"prettyprint\">#!/usr/bin/env&nbsp;python3#&nbsp;-*-&nbsp;coding:&nbsp;UTF-8&nbsp;-*-APPID&nbsp;=&nbsp;&#39;Your&nbsp;AppId&#39;APPKey&nbsp;=&nbsp;&#39;Your&nbsp;AppKey&#39;1234512345</pre><p>将自己申请得到的参数填写到上面的文件中。然后我们创建 <code>fanyi.py</code> 文件，写入以下代码：</p><pre class=\"prettyprint\">#!/usr/bin/env&nbsp;python3#&nbsp;-*-&nbsp;coding:&nbsp;UTF-8&nbsp;-*-import&nbsp;requestsimport&nbsp;argparseimport&nbsp;randomimport&nbsp;hashlibimport&nbsp;jsonfrom&nbsp;config&nbsp;import&nbsp;APPID,&nbsp;APPKeyfrom&nbsp;prettytable&nbsp;import&nbsp;PrettyTabledef&nbsp;fanyi(word,&nbsp;goNext):\r\n&nbsp;&nbsp;&nbsp;&nbsp;baseUrl&nbsp;=&nbsp;&#39;https://openapi.youdao.com/api&#39;\r\n&nbsp;&nbsp;&nbsp;&nbsp;salt&nbsp;=&nbsp;str(random.randint(1000000,&nbsp;9999999))\r\n&nbsp;&nbsp;&nbsp;&nbsp;sign&nbsp;=&nbsp;APPID&nbsp;+&nbsp;word&nbsp;+&nbsp;salt&nbsp;+&nbsp;APPKey\r\n&nbsp;&nbsp;&nbsp;&nbsp;m1&nbsp;=&nbsp;hashlib.md5()\r\n&nbsp;&nbsp;&nbsp;&nbsp;m1.update(sign.encode(&#39;utf-8&#39;))\r\n&nbsp;&nbsp;&nbsp;&nbsp;md5Sign&nbsp;=&nbsp;m1.hexdigest()\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;queryFrom&nbsp;=&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;appKey&#39;:&nbsp;APPID,\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;q&#39;:&nbsp;word,\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;from&#39;:&nbsp;&#39;auto&#39;,\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;to&#39;:&nbsp;&#39;auto&#39;,\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;salt&#39;:&nbsp;salt,\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#39;sign&#39;:&nbsp;md5Sign,\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;requests.post(baseUrl,&nbsp;data=queryFrom)\r\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;r.status_code&nbsp;==&nbsp;200:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;=&nbsp;json.loads(r.text)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;res[&#39;errorCode&#39;]&nbsp;==&nbsp;&#39;0&#39;:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;showRes(word,&nbsp;res)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;goNext:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&#39;\\n&#39;)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputWord(False)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(res[&#39;errorCode&#39;])\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit()\r\n&nbsp;&nbsp;&nbsp;&nbsp;else:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(r.status_code)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit()def&nbsp;showRes(word,&nbsp;res):\r\n&nbsp;&nbsp;&nbsp;&nbsp;tableHead&nbsp;=&nbsp;[&#39;原词&#39;,&nbsp;word]\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;PrettyTable(tableHead)\r\n&nbsp;&nbsp;&nbsp;&nbsp;x.padding_width&nbsp;=&nbsp;1\r\n&nbsp;&nbsp;&nbsp;&nbsp;x.align&nbsp;=&nbsp;&#39;l&#39;\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;print(&#39;\\n\\033[1;36m简单结果\\033[0m&#39;)\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;res[&#39;translation&#39;]:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.add_row([&#39;结果&#39;,&nbsp;i])\r\n&nbsp;&nbsp;&nbsp;&nbsp;print(x)\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;&#39;basic&#39;&nbsp;in&nbsp;res:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&#39;\\n\\033[1;36m有道词典\\033[0m&#39;)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;basic&nbsp;=&nbsp;res[&#39;basic&#39;]\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;&#39;wfs&#39;&nbsp;in&nbsp;basic:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wfs&nbsp;=&nbsp;basic[&#39;wfs&#39;]\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;PrettyTable([&#39;演化&#39;,&nbsp;&#39;结果&#39;])\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.padding_width&nbsp;=&nbsp;1\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.align&nbsp;=&nbsp;&#39;l&#39;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;wfs:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.add_row([i[&#39;wf&#39;][&#39;name&#39;],&nbsp;i[&#39;wf&#39;][&#39;value&#39;]])\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(x)\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;&#39;explains&#39;&nbsp;in&nbsp;basic:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exps&nbsp;=&nbsp;basic[&#39;explains&#39;]\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;PrettyTable([&#39;示例&#39;])\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.padding_width&nbsp;=&nbsp;1\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.align&nbsp;=&nbsp;&#39;l&#39;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;exps:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.add_row([i])\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(x)\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;&#39;web&#39;&nbsp;in&nbsp;res:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&#39;\\n\\033[1;36m网络释义\\033[0m&#39;)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;PrettyTable([&#39;相关词汇&#39;,&nbsp;&#39;翻译&#39;])\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.padding_width&nbsp;=&nbsp;1\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.align&nbsp;=&nbsp;&#39;l&#39;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;res[&#39;web&#39;]:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x.add_row([i[&#39;key&#39;],&nbsp;&#39;,&nbsp;&#39;.join(i[&#39;value&#39;])])\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(x)def&nbsp;inputWord&nbsp;(isFirst):\r\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;isFirst:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&#39;\\n\\033[1;36m英汉互译词典\\033[0m&nbsp;by&nbsp;FungLeo&#39;)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&#39;\\033[35mTip：退出程序请输入&nbsp;\\033[1;31mexit\\033[4;0m\\n&#39;)\r\n&nbsp;&nbsp;&nbsp;&nbsp;word&nbsp;=&nbsp;input(&#39;请输入要翻译的内容：&#39;)\r\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;word&nbsp;==&nbsp;&#39;exit&#39;:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(&#39;\\033[0m很高兴为您服务&#39;)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit()\r\n&nbsp;&nbsp;&nbsp;&nbsp;else:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fanyi(word,&nbsp;True)if&nbsp;__name__&nbsp;==&nbsp;&#39;__main__&#39;:\r\n&nbsp;&nbsp;&nbsp;&nbsp;parser&nbsp;=&nbsp;argparse.ArgumentParser()\r\n&nbsp;&nbsp;&nbsp;&nbsp;parser.description&nbsp;=&nbsp;&#39;YouDao&nbsp;Fanyi&nbsp;Cli&#39;\r\n&nbsp;&nbsp;&nbsp;&nbsp;parser.add_argument(&#39;-v&#39;,&nbsp;&#39;--version&#39;,&nbsp;action&nbsp;=&nbsp;&#39;version&#39;,&nbsp;version&nbsp;=&nbsp;&#39;%(prog)s&nbsp;V0.0.1&#39;)\r\n&nbsp;&nbsp;&nbsp;&nbsp;parser.add_argument(&#39;word&#39;,&nbsp;type&nbsp;=&nbsp;str,&nbsp;help&nbsp;=&nbsp;&#39;需要翻译的单词&#39;,&nbsp;nargs&nbsp;=&nbsp;&#39;?&#39;)\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;args&nbsp;=&nbsp;parser.parse_args()\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;args.word&nbsp;==&nbsp;None:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inputWord(True)\r\n&nbsp;&nbsp;&nbsp;&nbsp;else:\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fanyi(args.word,&nbsp;False)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109</pre><p>如上代码就开发完成了。代码逻辑没什么要说的，只是简单的请求接口，另外把拿到的数据进行了一些美化而已。此外就是命令行工具的一些基本配置了。</p><p>有道翻译官方文档地址：<a href=\"http://ai.youdao.com/docs/doc-trans-api.s\" target=\"_blank\">http://ai.youdao.com/docs/doc-trans-api.s</a></p><h2><a></a><a target=\"_blank\"></a>测试</h2><p>我们可以用 <code>-v</code> 以及 <code>-h</code> 来分别查看版本号以及帮助信息。如下图所示：</p><p><br/></p><p><br/></p>', 'Python', 'Python', '原创', '编程语言', '已发布', 'a3c904ef7cc44272adfb49094a5822a4', '2018年09月26日 10:54:44', '12', '1', 'wolaile');
INSERT INTO `article` VALUES ('411d9db7a95a4991bb6f475a88200611', 'Python模块搜索路径', '<p>最近在学习python的C++扩展（pybind11)，写完一个扩展模块之后，想要在自己的环境中以后都能自动导入这个模块，而不用手动去添加路径(修改sys.path)应该怎么弄？以前最开始学习Python的时候看过这块内容，然而时间长了总会记忆不清，就再回顾了一遍。&nbsp;</p><p>概括来说，Python的自动搜索路径是这样的：</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p>程序的根目录</p><p>PYTHONPATH环境变量设置的目录</p><p>标准库的目录</p><p>任何能够找到的.pth文件的内容</p><p>第三方扩展的site-package目录</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p>最终，这五个部分的拼接成为了sys.path，其中第一和第三、第五部分是自动定义的。&nbsp;</p><p>根目录(自动)&nbsp;</p><p>Python首先在根目录搜索要导入的文件。这个根目录的入口依赖于你怎么运行代码；当你运行一个程序时，这个入口就是程序运行入口(top-level script file)文件所在的目录；当你用交互式窗口期运行代码时，这个入口就是你所在的工作目录。&nbsp;</p><p>PYTHONPATH 目录(可配置的)&nbsp;</p><p>接下来，python会搜索PYTHONPATH环境变量里列出的所有目录，因为这个搜索在标准库之前，所以要小心不要覆盖一些标准库的同名模块。&nbsp;</p><p>标准库目录(自动)&nbsp;</p><p>这个没什么好说的，pyton会自动搜寻标准库模块所在的目录。&nbsp;</p><p>.pth文件列出的目录(可配置的)&nbsp;</p><p>这是用的比较少的一个python特性。它允许用户以每行一个的方式列出搜索路径，它和PYTHONPATH环境变量的不同是会在标准库路径之后搜索；而且它是针对这个python安装的，而不是针对用户的（环境变量会随着用户的不同而不同）。 那么，.pth文件应该放在哪里呢？可以通过以下代码找到.pth文件可以放置的位置：</p><p><br/></p><p><br/></p><p><br/></p><p>import site</p><p>site.getsitepackages()12</p><p><br/></p><p>在我的环境中，输出如下：</p><p><br/></p><p><br/></p><p><br/></p><p>[&#39;C:\\\\Python27&#39;, &#39;C:\\\\Python27\\\\lib\\\\site-packages&#39;]1</p><p><br/></p><p>Lib/site-package目录(自动)&nbsp;</p><p>最后，python会在搜索路径上自动加上site-packages目录，这一般是第三方扩展安装的地方，一般是由distutils工具发布的。</p><p><br/></p><p><br/></p><p><br/></p><p>举例说明</p><p><br/></p><p>讲了这么多，现在我们举个小栗子。我的python环境是windows7 + python 2.7。&nbsp;</p><p>1. 首先，我们新建一个环境变量PYTHONPATH，在里面加上目录E:\\python_extensions</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p>然后，我们在C:\\Python27目录下新增一个add.pth文件，里面的内容是：&nbsp; E:\\python_extensions2</p><p>最后，我们在E:\\python_extensions和E:\\python_extensions2目录下分别新建模块test.py和test2.py，里面都写了一个test方法。&nbsp;</p><p>我们打开交互解释器，结果如下：</p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p>可以看到，我们可以直接导入这两个目录下的模块了。查看sys.path:</p><p><br/></p><p><br/></p><p><br/></p><p>嗯，这两个路径已经自动加入sys.path变量了。</p><p><br/></p><p><br/></p><p><br/></p><p>总结</p><p><br/></p><p>本文简要回顾了python的自动搜索路径，以及如何配置一些搜索路径以使得python在启动时能够将某些目录加到搜索路径。当然，这些自动搜索路径随着python版本和实现的不同会有细微差别，但对于目前的使用来说已经够了。</p><p><br/></p><p><br/></p><p><br/></p><p>参考文献</p><p><br/></p><p><br/></p><p>《Learning Python, 5th Edition》, Chapter 22: Modules: The Big Picture, The Modules Search Path</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p><p><span style=\"white-space:pre\">						</span></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p><p><span style=\"white-space:pre\">		</span></p><p><span style=\"white-space:pre\">			</span></p><p><br/></p><p>---------------------</p><p><br/></p><p>本文来自 fitzzhang 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/fitzzhang/article/details/78988155?utm_source=copy&nbsp;</p><p><br/></p>', '运营,维护', '', '原创', '运维', '草稿', '71214c5d9cff4d4bb2bf06615788d005', '2018年09月24日 15:01:39', '0', '0', 'TANG');
INSERT INTO `article` VALUES ('4611b84ce25544f6882d2249b27ad655', 'Java 输入流和输出流的应用', '<p>关于输入流和输出流的使用我一直都很迷惑。到底什么时候用输入流什么时候用输出流这里举个栗子给大家看看就能很容易的记住并理解了</p><p>打比方说两个聊天程序A和B进行对话。底层通过IO流来实现的。</p><p>第一步： A向B发送一个消息。那么A会创建一个输出流，将数据写入到输出流里面然后发送出去。 <br/>第二步： B收到了A发送过来的数据，其实就是IO流。这时候对于B来说这个IO流就是输入流了。因为是从A发送过来的流，所以就是输入流。当B需要得到输入流中的数据的时候就需要读出输入流中的数据。这也就是另一个迷惑人的地方。</p><p>输入流要被读，而输出流要往里写。这一点一定要记住。</p><p>总结： <br/><strong>数据写入到输入流 ， 然后发送 &nbsp;, &nbsp;然后，另一个端获取到的流是输出流。就要读出</strong></p><p>刚开始写vue项目的时候，会出现一些基础的错误，这里小小的总结一下。</p><h2><a></a><a target=\"_blank\"></a>一、space、tab报错</h2><pre class=\"prettyprint\">Unexpected&nbsp;tab&nbsp;character\r\nMissing&nbsp;space&nbsp;before&nbsp;function&nbsp;parentheses\r\nexpected&nbsp;&quot;indent&quot;,&nbsp;got&nbsp;&quot;outdent&quot;123</pre><p>这些报错都是空格和tab的报错问题</p><p><strong>解决方法</strong>：</p><ul class=\" list-paddingleft-2\"><li><p>1、因为你设置了eslint，如果你不想有规范的js代码，可以重新初始化关掉eslint。</p></li></ul><p><code>Use ESLint to lint your code? (Y/n)</code> 这一步选no</p><h2>二、标签不变色问题</h2><ul class=\" list-paddingleft-2\"><li><p>1、vue后缀的文件标签不变色</p></li></ul><p>下载一个<strong>vue-syntax-highlight-master</strong>的插件即可，下载完成后复制到<strong>Sublime Text3\\Data\\Packages</strong>目录下（在sublime中点击 <strong>首选项-浏览插件</strong>即可进入该目录）</p><ul class=\" list-paddingleft-2\"><li><p>2、style标签下不变色</p></li></ul><p>若设置了属性**<code>lang=stylus</code><strong>，下载</strong>stylus插件**即可</p><p>步骤如下：</p><p><strong>首选项-package control-install package-stylus</strong></p><h2><a></a><a target=\"_blank\"></a>三、package controll报错</h2><p>需要下载<strong>package control</strong>才能在<strong>sublime</strong>安装插件</p><p>解决方法就是下载一个新的package control 替换掉原来的就可以了</p><ul class=\" list-paddingleft-2\"><li><p>1、在百度搜索package control，点击搜索项第一个，即为package control官网。</p></li><li><p>2、在打开后的页面，点击绿色按钮<code>“install now”</code>，跳转到安装页面</p></li></ul><p>一种是下载package control的应用程序，<br/> 另一种是simple方法。</p><p>这里分为sublime text2 &nbsp; 和sublime text3 安装，根据自己的版本选择合适的安装方法。</p><p>复制安装命令。</p><ul class=\" list-paddingleft-2\"><li><p>4、打开sublime text3 软件，选择 view（视图），命令行，或者按快捷键Ctrl +·(tab键上面那个键)，即可打开命令行。</p></li><li><p>5、在命令行中粘贴步骤3中的复制内容</p></li><li><p>6、回车进行安装。</p></li></ul><p><br/></p><p><br/></p>', 'Java,IO操作', 'Java', '原创', '后端', '已发布', 'f7fc09d439f34fecaf747db52d7ba396', '2018年09月25日 18:06:43', '5', '0', 'yangming');
INSERT INTO `article` VALUES ('5e8cfb91d22d4dc7985bdbb3674bed6d', '文章', '<p>啊啊啊</p>', '', '', '0', '0', '回收', 'a3c904ef7cc44272adfb49094a5822a4', '2018年09月25日 14:49:03', '0', '0', 'wolaile');
INSERT INTO `article` VALUES ('65104286801e48658c9cecd9f8ac6641', 'redis 的应用范围和学习路线', '<p>在安装redis 的时候要安装gcc</p><p><br/></p><p>使用yum安装gcc 在有网络连接条件下进行 分别执行如下命令：</p><p><br/></p><p>#安装gcc、c++编译器以及内核文件</p><p><br/></p><p>在线安装gcc</p><p><br/></p><p>yum -y install gcc gcc-c++ kernel-devel</p><p><br/></p><p>#如果没有安装make： yum install make</p><p><br/></p><p>#验证安装成功的方法： gcc -v或者：g++ -v</p><p><br/></p><p>如果显示的gcc版本仍是以前的版本，可以重启系统；</p><p><br/></p><p>#查看gcc的安装位置： which gcc；</p><p><br/></p><p>在线安装这里没有对gmp、mpfr、mpc等软件分别进</p><p><br/></p><p>---------------------</p><p><br/></p><p>本文来自 大阳彼岸 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/qq_20610631/article/details/82016327?utm_source=copy&nbsp;</p><p><br/></p>', '数据库,SQL', '', '原创', '编程语言', '已发布', 'a1097602c3174132952e56ef8840d7cb', '2018年09月25日 15:07:52', '4', '0', 'YANG');
INSERT INTO `article` VALUES ('7a9f99dca82f49f4813a22eb600b58f3', 'SSD算法代码介绍（一）：训练参数配置', '<p>SSD算法是object detection领域比较经典的算法，github上有一个写得比较好的MXNet版本的实现代码，项目地址：https://github.com/zhreshold/mxnet-ssd，目前该项目代码也已经并入MXNet官方github。想要本地实现可以参考项目地址中README.md的介绍或者参考博客：SSD算法的MXNet实现。</p><p><br/></p><p>接下来这一系列博客想介绍该代码中关于实现SSD算法的一些细节，也会涉及部分Python语言的巧妙代码，以训练模型为切入口展开介绍，最好按顺序阅读，详细注释已经在代码中给出。</p><p><br/></p><p>这一篇博客介绍训练模型的入口代码：train.py脚本，该脚本主要包含一些参数设置和主函数。</p><p><br/></p><p><br/></p><p><br/></p><p>import argparse</p><p>import tools.find_mxnet</p><p>import mxnet as mx</p><p>import os</p><p>import sys</p><p>from train.train_net import train_net</p><p><br/></p><p>def parse_args():</p><p>&nbsp; &nbsp; parser = argparse.ArgumentParser(description=&#39;Train a Single-shot detection network&#39;)</p><p>&nbsp; &nbsp; parser.add_argument(&#39;--train-path&#39;, dest=&#39;train_path&#39;, help=&#39;train record to use&#39;,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default=os.path.join(os.getcwd(), &#39;data&#39;, &#39;train.rec&#39;), type=str)</p><p>&nbsp; &nbsp; parser.add_argument(&#39;--train-list&#39;, dest=&#39;train_list&#39;, help=&#39;train list to use&#39;,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default=&quot;&quot;, type=str)</p><p>&nbsp; &nbsp; parser.add_argument(&#39;--val-path&#39;, dest=&#39;val_path&#39;, help=&#39;validation record to use&#39;,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default=os.path.join(os.getcwd(), &#39;data&#39;, &#39;val.rec&#39;), type=str)</p><p>&nbsp; &nbsp; parser.add_argument(&#39;--val-list&#39;, dest=&#39;val_list&#39;, help=&#39;validation list to use&#39;,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default=&quot;&quot;, type=str)</p><p>&nbsp; &nbsp; parser.add_argument(&#39;--network&#39;, dest=&#39;network&#39;, ty</p><p><br/></p><p>---------------------</p><p><br/></p><p>本文来自 AI之路 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/u014380165/article/details/79332339?utm_source=copy&nbsp;</p><p><br/></p>', '编程 ,语言', '', '转载', '编程语言', '草稿', '71214c5d9cff4d4bb2bf06615788d005', '2018年09月25日 15:03:30', '0', '0', 'TANG');
INSERT INTO `article` VALUES ('8a81fa10c7e7459f922d71ba8109fa3d', 'Redis学习——redis.conf 配置文件介绍', '<p>在Redis的使用过程，除了知道对Redis五种数据类型的操作方法之外，最主要额就是对redis.conf进行配置了,下面整理出redis.conf中常见的一些配置介绍。 <br/><strong>参数说明</strong> <br/>redis.conf 配置项说明如下：</p><pre class=\"prettyprint\">1:&nbsp;Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程\r\n&nbsp;&nbsp;&nbsp;&nbsp;daemonize&nbsp;no2:&nbsp;当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定\r\n&nbsp;&nbsp;&nbsp;&nbsp;pidfile&nbsp;/var/run/redis.pid3:&nbsp;指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，\r\n因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia&nbsp;Merz的名字\r\n&nbsp;&nbsp;port&nbsp;63794:&nbsp;绑定的主机地址\r\n&nbsp;&nbsp;bind&nbsp;127.0.0.15:&nbsp;当&nbsp;客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能\r\n&nbsp;&nbsp;timeout&nbsp;3006:&nbsp;指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，\r\n默认为verbose\r\n&nbsp;&nbsp;loglevel&nbsp;verbose7:&nbsp;日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志\r\n记录方式为标准输出，则日志将会发送给/dev/null\r\n&nbsp;&nbsp;logfile&nbsp;stdout8:&nbsp;设置数据库的数量，默认数据库为0，可以使用SELECT&nbsp;&lt;dbid&gt;命令在连接上指定数据库id\r\n&nbsp;&nbsp;databases&nbsp;169:&nbsp;指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\r\n&nbsp;&nbsp;save&nbsp;&lt;seconds&gt;&nbsp;&lt;changes&gt;\r\n&nbsp;&nbsp;Redis默认配置文件中提供了三个条件：\r\n&nbsp;&nbsp;save&nbsp;900&nbsp;1\r\n&nbsp;&nbsp;save&nbsp;300&nbsp;10\r\n&nbsp;&nbsp;save&nbsp;60&nbsp;10000\r\n&nbsp;&nbsp;分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。10:&nbsp;指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，\r\n可以关闭该选项，但会导致数据库文件变的巨大\r\n&nbsp;&nbsp;rdbcompression&nbsp;yes11:&nbsp;指定本地数据库文件名，默认值为dump.rdb\r\n&nbsp;&nbsp;dbfilename&nbsp;dump.rdb12:&nbsp;指定本地数据库存放目录\r\n&nbsp;&nbsp;dir&nbsp;./13:&nbsp;设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步\r\n&nbsp;&nbsp;slaveof&nbsp;&lt;masterip&gt;&nbsp;&lt;masterport&gt;14:&nbsp;当master服务设置了密码保护时，slav服务连接master的密码\r\n&nbsp;&nbsp;masterauth&nbsp;&lt;master-password&gt;15:&nbsp;设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH&nbsp;&lt;password&gt;命令提供密码，默认关闭\r\n&nbsp;&nbsp;requirepass&nbsp;foobared16:&nbsp;设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，\r\n如果设置&nbsp;maxclients&nbsp;0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端\r\n返回max&nbsp;number&nbsp;of&nbsp;clients&nbsp;reached错误信息\r\n&nbsp;&nbsp;maxclients&nbsp;12817:&nbsp;指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，\r\n当此方法处理&nbsp;后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，\r\nValue会存放在swap区\r\n&nbsp;&nbsp;maxmemory&nbsp;&lt;bytes&gt;18:&nbsp;指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。\r\n因为&nbsp;redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no\r\n&nbsp;&nbsp;appendonly&nbsp;no19:&nbsp;指定更新日志文件名，默认为appendonly.aof\r\n&nbsp;&nbsp;&nbsp;appendfilename&nbsp;appendonly.aof20:&nbsp;指定更新日志条件，共有3个可选值：&nbsp;\r\n&nbsp;&nbsp;no：表示等操作系统进行数据缓存同步到磁盘（快）&nbsp;\r\n&nbsp;&nbsp;always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）&nbsp;\r\n&nbsp;&nbsp;everysec：表示每秒同步一次（折衷，默认值）\r\n&nbsp;&nbsp;appendfsync&nbsp;everysec21:&nbsp;指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，\r\n访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）\r\n&nbsp;&nbsp;&nbsp;vm-enabled&nbsp;no22:&nbsp;虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享\r\n&nbsp;&nbsp;&nbsp;vm-swap-file&nbsp;/tmp/redis.swap23:&nbsp;将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据&nbsp;就是keys),\r\n也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0\r\n&nbsp;&nbsp;&nbsp;vm-max-memory&nbsp;024:&nbsp;Redis&nbsp;swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，\r\nvm-page-size是要根据存储的&nbsp;数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；\r\n如果存储很大大对象，则可以使用更大的page，如果不&nbsp;确定，就使用默认值\r\n&nbsp;&nbsp;&nbsp;vm-page-size&nbsp;3225:&nbsp;设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。\r\n&nbsp;&nbsp;&nbsp;vm-pages&nbsp;13421772826:&nbsp;设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，\r\n可能会造成比较长时间的延迟。默认值为4\r\n&nbsp;&nbsp;&nbsp;vm-max-threads&nbsp;427:&nbsp;设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启\r\n&nbsp;&nbsp;glueoutputbuf&nbsp;yes28:&nbsp;指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法\r\n&nbsp;&nbsp;hash-max-zipmap-entries&nbsp;64\r\n&nbsp;&nbsp;hash-max-zipmap-value&nbsp;51229:&nbsp;指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）\r\n&nbsp;&nbsp;activerehashing&nbsp;yes30:&nbsp;指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件\r\n&nbsp;&nbsp;include&nbsp;/path/to/local.conf</pre><p><br/></p>', 'Redis,大数据', '数据库,大数据', '原创', '数据库', '已发布', 'a3c904ef7cc44272adfb49094a5822a4', '2018年09月27日 09:01:57', '20', '0', 'wolaile');
INSERT INTO `article` VALUES ('8ae77b47b45045d49246e085cabf4f91', '游戏开发入门（二）游戏中的设计模式', '<p><strong>笔记与总结（请先学习视频内容）：</strong></p><p><strong>1.有必要深刻的认识到设计模式的意义</strong> <br/>游戏开发是一个软件工程，他的特点是需求极易变化。对于任何一个软件工程，我们要从代码的组织方式上来提高其可读性（别人也很容易理解），安全性（不能经常出bug），易用性（逻辑复杂，思路太偏，使用上各种麻烦），健壮性（要能良好的处理意外情况），可维护性（是否容易修复与修改），可拓展性（是否容易添加功能），封装和复用性（一段代码不要到处拷贝粘贴）</p><p><strong>2.游戏项目的特点</strong> <br/>对于游戏项目来说，除了上面的问题，我们更要注意其可拓展性，因为游戏的需求每天都可能发生变化，所以在写游戏逻辑的时候一定要尽可能的考虑多种情况，考虑到以后的修改是否方便等。因此，我们需要尽可能降低代码的耦合性，做到不同的功能尽可能不要互相影响。不过，这里的降低耦合不仅仅是指自己写的模块间的耦合，还有考虑与别人写的模块的耦合，尽可能做到不要过分依赖别人的模块，这样别人代码的一点修改不至于造成我们代码的大规模修改。</p><p><strong>3.不要过度设计</strong> <br/>因为需求变化太过频繁，很可能你针对当前需求设计的是否完美的一个方案在第二天需求变更时就完全失效了。另外，对一个需求的设计是需要时间成本的，也许花费一个星期才思考一个近乎完美的解决方案，但第二个星期需求就改了，这一个星期的时间几乎完全浪费。这一点几乎无法完全掌握，但是可以通过经验积累尽量避免问题。</p><p><strong>4.游戏性能是一项非常重要的指标</strong> <br/>游戏与其他软件不同的是，很多游戏逻辑不是消息驱动，需要每帧都去调用。所以，我们在向Tick()函数里面添加方法时，都要去思考能不能换一种方式驱动来减小函数执行的开销。</p><p><strong>5.工厂模式：简单工厂，普通工厂，抽象工厂</strong> <br/>所谓工厂，目的就是生产产品。所以，我们至少封装一个工厂类和一个产品类。一般来说呢，一个工厂又不会只生产一种产品。所以呢，我们把产品抽象一下，可以基于这个产品派生出多种类似的产品。这样就是一种<strong>简单工厂</strong>了，该工厂可以生产一个类型不同系列的多种产品。举例来说，一个制造厂生产民用飞机，战斗机，无人机。那么这三种飞机就是同一个类型（都是飞机），不过系列不同（应用场景不同）。</p><p>当然呢，有的时候为了分工明确，我不想一个工厂生产所有类型的产品，所以我把工厂抽象一下，不同类型的工厂生产相同类型不同系列的产品。这也是一种工厂模式，我们就称他为<strong>普通工厂</strong>吧。举例：我不能让战斗机与民用飞机在同一个厂子生产，所以呢，再弄一个新的战斗机制造厂专门生产战斗机，而民用机弄一个新的民用制造厂来制作。</p><p><strong>那么什么是抽象工厂？</strong> <br/>上面简单工厂不管怎么抽象，一个具体的工厂只生产一种特定的产品。抽象工厂的每个具体的工厂可以生产多种产品。举例：制造厂发现平时生产飞机多出来很多材料，扔了太浪费了，所以研究一下生产点小型汽车。这样，一个民用飞机制造厂又可以生产汽车了，然后改名为民用制造厂。战斗机工厂生产防弹车，改名叫军用制造厂。</p><p><strong>对比一下简单工厂，普通工厂与抽象工厂：</strong> <br/>简单工厂只有一种工厂，负责生产同一类型的所有产品，所以可以简单的都在一个工厂处理，工厂不需要抽象，但是由于产品可能有多种，所以产品有必要抽象。 <br/>普通工厂有多种工厂但是每个工厂只生产同一类型同一系列的一种产品，考虑到同一类型的产品可能有多种而且一个系列的产品对应一个工厂，所以产品与工厂都有必要抽象。 <br/>抽象工厂有多种工厂，每种工厂都可能生产多种类型的产品。考虑到同一类型的产品可能有多种，所以也有必要抽象。</p><blockquote><p>游戏设计中的工厂模式： 游戏GamePlay逻辑游戏世界里面需要频繁生成与创建的对象都可以通过工厂模式来管理。如刷怪，然后可以根据怪的种类再进一步抽象成普通工厂。</p></blockquote><p><strong>6.Builder模式：</strong> <br/>细分一个对象的构造细节并拆分，达到可以自由调整构造顺序以及构造内容的效果。</p><p><br/></p><p><br/></p>', '游戏,设计模式', '游戏', '原创', '游戏开发', '已发布', 'a3c904ef7cc44272adfb49094a5822a4', '2018年09月27日 08:50:56', '191', '2', 'wolaile');
INSERT INTO `article` VALUES ('9bec87cc3d334eb484ac40fc73b2f07c', ' java开发Demo~微信扫码支付，java开发示例', '<h2>开发所需工具类</h2><p>以上工具类以上传到我的资源，下载地址 <br/><a href=\"http://download.csdn.net/download/han_xiaoxue/10184832\" target=\"_blank\">http://download.csdn.net/download/han_xiaoxue/10184832</a></p><h2><a></a>开发所需jar</h2><p><img src=\"https://img-blog.csdn.net/20180102184808983?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW94dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\"/></p><h3><a></a>具体的代码不贴了，说明下PayConfigUtil中的参数</h3><p><img src=\"https://img-blog.csdn.net/20180102182613539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGFuX3hpYW94dWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\"/> <br/>APP_ID和APP_SECRET在公众平台 <br/>MCH_ID和API_KEY在商户平台,其中API_KEY是自己设置的，并不是自动生成的。</p><h2>Controller</h2><p><strong>通过此方法，前往可以生成二维码的页面</strong></p><pre class=\"prettyprint\">//微信前往支付页面\r\n&nbsp;&nbsp;&nbsp;&nbsp;@RequestMapping(value&nbsp;=&nbsp;&quot;towxPay&quot;)&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ModelAndView&nbsp;towxPay(ModelMap&nbsp;map,HttpServletRequest&nbsp;request,String&nbsp;chapterId,String&nbsp;chapterName,String&nbsp;price)&nbsp;throws&nbsp;IOException{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ModelAndView&nbsp;mav&nbsp;=&nbsp;new&nbsp;ModelAndView();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mav.setViewName(&quot;jsp/pay/weixinpayma&quot;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpSession&nbsp;session&nbsp;=&nbsp;request.getSession();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.setAttribute(&quot;chapterId&quot;,&nbsp;chapterId);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.setAttribute(&quot;chapterName&quot;,&nbsp;chapterName);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.setAttribute(&quot;price&quot;,&nbsp;price);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;mav;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}1234567891011</pre><p><strong>返回的页面如下</strong></p><pre class=\"prettyprint\">&lt;%@&nbsp;page&nbsp;language=&quot;java&quot;&nbsp;contentType=&quot;text/html;&nbsp;charset=UTF-8&quot;&nbsp;pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@&nbsp;taglib&nbsp;uri=&quot;http://java.sun.com/jsp/jstl/core&quot;&nbsp;prefix=&quot;c&quot;%&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;%&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;path&nbsp;=&nbsp;request.getContextPath();&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;basePath&nbsp;=&nbsp;request.getScheme()&nbsp;+&nbsp;&quot;://&quot;&nbsp;+&nbsp;request.getServerName()&nbsp;+&nbsp;&quot;:&quot;&nbsp;+&nbsp;request.getServerPort()\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;path&nbsp;+&nbsp;&quot;/&quot;;\r\n%&gt;&lt;html&gt;&lt;head&gt;&lt;meta&nbsp;http-equiv=&quot;Content-Type&quot;&nbsp;content=&quot;text/html;&nbsp;charset=UTF-8&quot;&gt;&lt;title&gt;Insert&nbsp;title&nbsp;here&lt;/title&gt;&lt;script&nbsp;src=&quot;&lt;%=basePath%&gt;js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;wxpayma&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;访问Controller的index/payImg方法，将生成的二维码图片显示在这&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img&nbsp;alt=&quot;&quot;&nbsp;src=&quot;&lt;%=basePath%&gt;index/payImg&quot;&gt;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;ajax轮回，不停的访问Controller，直到wxPayType=1时，付款成功&nbsp;*/\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;num&nbsp;=&nbsp;0;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(function(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panduanWXPay();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;panduanWXPay(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$.post(&quot;&lt;%=basePath%&gt;index/panduanPay&quot;,function(data){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;wxPayType&nbsp;=&nbsp;data.wxPayType;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(wxPayType==1){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;成功&nbsp;*/\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;window.location.href=&#39;&lt;%=basePath%&gt;index/gouMai&#39;;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;if(wxPayType==0&nbsp;&amp;&amp;&nbsp;num!=400){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num++;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;panduanWXPay();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(&quot;支付超时&quot;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;1234567891011121314151617181920212223242526272829303132333435363738394041</pre><p><strong>payImg方法</strong></p><pre class=\"prettyprint\">//微信支付，生成二维码\r\n&nbsp;&nbsp;&nbsp;&nbsp;@RequestMapping(value&nbsp;=&nbsp;&quot;payImg&quot;)&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;&nbsp;void&nbsp;payImg(HttpServletRequest&nbsp;request,&nbsp;HttpServletResponse&nbsp;response)&nbsp;throws&nbsp;IOException{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpSession&nbsp;session&nbsp;=&nbsp;request.getSession();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;chapterName=(String)session.getAttribute(&quot;chapterName&quot;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;price=(String)session.getAttribute(&quot;price&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;defaultWidthAndHeight=200;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;nonce_str&nbsp;=&nbsp;PayCommonUtil.getNonce_str();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;time_stamp&nbsp;=&nbsp;System.currentTimeMillis()&nbsp;/&nbsp;1000;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;product_id&nbsp;=&nbsp;chapterName+&quot;*&quot;+price;//订单名字和价钱，拼到了一起，后面用到的时候再拆\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;key&nbsp;=&nbsp;PayConfigUtil.API_KEY;&nbsp;//&nbsp;key\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SortedMap&lt;Object,&nbsp;Object&gt;&nbsp;packageParams&nbsp;=&nbsp;new&nbsp;TreeMap&lt;Object,&nbsp;Object&gt;();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packageParams.put(&quot;appid&quot;,&nbsp;PayConfigUtil.APP_ID);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packageParams.put(&quot;mch_id&quot;,&nbsp;PayConfigUtil.MCH_ID);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packageParams.put(&quot;time_stamp&quot;,&nbsp;String.valueOf(time_stamp));\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packageParams.put(&quot;nonce_str&quot;,&nbsp;nonce_str);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packageParams.put(&quot;product_id&quot;,&nbsp;product_id);//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packageParams.put(&quot;chapterId&quot;,&nbsp;chapterId);//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packageParams.put(&quot;price&quot;,&nbsp;price);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;sign&nbsp;=&nbsp;PayCommonUtil.createSign(&quot;UTF-8&quot;,&nbsp;packageParams,key);//MD5哈希\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packageParams.put(&quot;sign&quot;,&nbsp;sign);&nbsp;\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//生成参数\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;str&nbsp;=&nbsp;ToUrlParams(packageParams);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;payurl&nbsp;=&nbsp;&quot;weixin://wxpay/bizpayurl?&quot;&nbsp;+&nbsp;str;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logger.info(&quot;payurl:&quot;+payurl);</pre><p><br/></p><p><br/></p>', 'Java,微信小程序', 'Java', '原创', '编程语言', '回收', 'f7fc09d439f34fecaf747db52d7ba396', '2018年09月26日 19:39:49', '7', '0', 'yangming');
INSERT INTO `article` VALUES ('ad0b7fd4c29e48e7af1913c0a4dab054', 'java123', '<p><span style=\"font-size: 24px; color: rgb(255, 0, 0);\"><em><strong>第一段</strong></em></span></p><p>第二段</p>', 'java,123', 'java,后端', '原创', '编程语言', '已发布', 'f7fc09d439f34fecaf747db52d7ba396', '2018年09月28日 10:15:04', '0', '0', 'yangming');
INSERT INTO `article` VALUES ('ad2648acc438406cb92beec09e2645ea', 'Docker中的一些服务集成LDAP（apacheDS）', '<p>redmine集成ldap相对gitlab来说要简单很多 后续补充 先以gitlab为例&nbsp; 因为都在docker中集成 所有有些会和普通集成有些差异，后面在做补充：</p><p>Gitlab：</p><p>GitLab有自己的用户机制，但其也兼容ldap协议。</p><p>docker中pull最新版本的gitlab和apacheDS</p><p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180903133659171?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpdUJpdUJpdV9fXw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"/></p><p>&nbsp;</p><p>apacheDS配置看历史博客即可。</p><p>gitlab需要集成LDAP的话不像redmine一样在可视化界面配置 而是需要去配置文件中更改</p><p>如果是将docker中的gitlab卷挂载到物理机上的话直接去挂载的目录下 找到gitlab.rb就可以修改</p><p>直接用exec进入docker中的gitlab，目录：/etc/gitlab/gitlab.rb</p><p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180903134455886?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JpdUJpdUJpdV9fXw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\"/></p><p><br/>1.1 修改配置文件gitlab.rb<br/>&nbsp;在gitlab.rb文件中添加下面配置，其中：<br/>1.host，是搭建的apacheDS的ip，根据实际情况修改（<span style=\"color:#f33b45;\"><strong>在docker中的ip并不是搭载docker物理机的地址，而是apacheDS这个容器的地址，docker inspect “</strong><em><strong>CONTAINER ID”</strong></em><strong> 即可查看</strong></span>）；<br/>2.uid，可以配置cn，也可以配置uid，都能识别；<br/>3.bind_dn，openldap的管理员账号，根据实际情况修改；<br/>4.password，openldap的管理员，根据实际情况修改；<br/>5.active_directory，似乎是针对连接是否是ad域控的标示，因为这部分是openldap的配置，故为false；<br/>6.allow_username_or_email_login，用户登录是否用户名和邮箱都可以，方便用户故配置true；<br/>7.base，用户列表所在的目录，因为新增的用户都在openldap的People下，故这么配置，根据实际情况修改；<br/># 指明服务的地址<br/>external_url = &#39;http://localhost&#39; （好像不加也可以 正在验证中）<br/># 开启ldap</p><pre class=\"has\">gitlab_rails[&#39;ldap_enabled&#39;]&nbsp;=&nbsp;truegitlab_rails[&#39;ldap_servers&#39;]&nbsp;=&nbsp;YAML.load&nbsp;&lt;&lt;-&#39;EOS&#39;&nbsp;###!&nbsp;**remember&nbsp;to&nbsp;close&nbsp;this&nbsp;block&nbsp;with&nbsp;&#39;EOS&#39;&nbsp;below**main:&nbsp;#&nbsp;&#39;main&#39;&nbsp;is&nbsp;the&nbsp;GitLab&nbsp;&#39;provider&nbsp;ID&#39;&nbsp;of&nbsp;this&nbsp;LDAP&nbsp;serverlabel:&nbsp;&#39;LDAP&#39;host:&nbsp;&#39;X.X.X.X&#39;#容器IPport:&nbsp;389uid:&nbsp;&#39;uid&#39;method:&nbsp;&#39;plain&#39;&nbsp;#&nbsp;&quot;tls&quot;&nbsp;or&nbsp;&quot;ssl&quot;&nbsp;or&nbsp;&quot;plain&quot;bind_dn:&nbsp;&#39;cn=Manager,dc=abc,dc=cn&#39;password:&nbsp;&#39;123456&#39;&nbsp;active_directory:&nbsp;falseallow_username_or_email_login:&nbsp;trueblock_auto_created_users:&nbsp;falsebase:&nbsp;&#39;ou=People,dc=abc,dc=cn&#39;user_filter:&nbsp;&#39;&#39;EOS</pre><p>1.2 重新加载新配置<br/># gitlab-ctl reconfigure</p><p>运行后最后一行为“gitlab Reconfigured!”才说明是加载新配置成功，否则就是根据报错信息找错误。</p><p>---------------------\r\n\r\n本文来自 BiuBiuBiu___ 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/BiuBiuBiu___/article/details/82347399?utm_source=copy&nbsp;</p><p><br/></p>', '大数据,Docker', '大数据', '原创', '云计算/大数据', '已发布', 'a3c904ef7cc44272adfb49094a5822a4', '2018年09月25日 14:45:50', '3', '0', 'wolaile');
INSERT INTO `article` VALUES ('ca86ad81397a4a5f9e5bfd4f14452463', 'HTML:CSS选择器介绍', '<p><span style=\"font-size: 24px; color: rgb(255, 0, 0);\"><em></em></span></p><p>本文将介绍各种选择器的定义方法。</p><h1><a></a>元素选择器：</h1><p>元素选择器是最简单的选择器，其语法格式如下：</p><pre class=\"has\">E{...}&nbsp;&nbsp;&nbsp;&nbsp;/*其中E代表有效的HTML元素名*/</pre><p>E甚至还可以用“*&#39;来表示元素名，”*“可匹配HTML文档中任意元素。</p><h1><a></a>属性选择器：</h1><p>属性选择器一共有如下几种语法格式。</p><blockquote><ul class=\" list-paddingleft-2\"><li><p>E{...}:指定该CSS样式对所有E元素起作用</p></li><li><p></p></li><li><p>E[attr]{...}:指定该CSS样式对具有attr属性的E元素起作用。</p></li><li><p></p></li><li><p>E[attr=value]{...}:指定该CSS样式对所有包含attr属性，且attr属性为value的E元素起作用。</p></li><li><p></p></li><li><p>E[attr~=value{...}:指定该CSS样式对所有包含attr属性，且attr属性的值为以空格隔开的系列值，其中某个值为value的E元素起作用。</p></li><li><p></p></li><li><p>E[attr|=value]{...}:指定该CSS样式对所有包含attr属性，且attr属性的值为以连字符隔开的系列值，其中第一个值为value的Tag元素起作用。</p></li><li><p></p></li><li><p>E[attr^=value]{...}:指定该CSS样式对所有包含attr属性，且attr属性的值为以value开头的字符串的E元素起作用。</p></li><li><p></p></li><li><p>E[attr$=value]{...}:指定该CSS样式对所有包含attr属性，且attr属性的值为以value结尾的字符串的E元素起作用。</p></li><li><p></p></li><li><p>E[attr*=value]{...}:指定该CSS样式对所有包含attr属性，且attr属性的值为包含value的字符串的E元素起作用。</p></li></ul></blockquote><p><span style=\"color:#f33b45;\"><strong>上面这几个选择器匹配规则越严格优先级越高。</strong></span></p><h1><a></a><strong>ID选择器：</strong></h1><p>ID选择器指定CSS样式将会对具有指定id属性值的HTML元素起作用.ID选择器的语法格式如下：</p><pre class=\"has\">#idValue{...}</pre><p>定义仅对指定元素起作用的ID选择器的语法格式如下:</p><pre class=\"has\">E#idValue{...}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*其中E是有效的HTML元素*/</pre><h1><a></a>Class选择器：</h1><p>class选择器的语法格式如下：</p><pre class=\"has\">[E].classValue{...}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*其中E是有效的HTML元素*/</pre><p>指定该CSS定义对class属性值为classValue的E元素起作用。此处的E可以省略，如果省略，则指定该CSS对所有的class属性值为classValue的元素起作用。</p><h1><a></a>包含选择器：</h1><p><br/></p><p><br/></p>', '前端,css,HTML', '前端', '原创', '前端', '已发布', 'f7fc09d439f34fecaf747db52d7ba396', '2018年09月27日 15:08:45', '28', '1', 'yangming');
INSERT INTO `article` VALUES ('cc0addf2f10d477ebf0fbffeea0219fc', '流式机器学习算法的入门和认知', '<h1>一.流式计算背景</h1><h2><a></a><a target=\"_blank\"></a>1.概述</h2><p>其实技术总在更新，做这个行业也是一直要走在学习并适应的路上，这也是人工智能领域最吸引我的地方，其实基础的理论是不变的，但是随着业务的发展，计算能力的发展，上层的实现总是在迭代，今天讲下我对于流计算的一些认知。<br/><img src=\"https://img-blog.csdn.net/20180919161846896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dzaGVuZ29k/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"在这里插入图片描述\"/></p><p>先聊下计算引擎的进化，随手画了上面的图。其实第一代分布式计算引擎是Hadoop，这是一个跨时代的创造，人们使用Hadoop的MapReduce框架实现了许多的算法，这些算法也发挥了很大的作用。Hadoop最大的特点是，数据计算依赖于硬盘存储，也就是说很多的计算过程中的结果都需要存在硬盘中，然后再从硬盘拉起，造成性能较低的问题。</p><p>Spark好在一点，把数据全部放到内存中进行计算，大大提高效率。但是无论是Spark或是Hadoop解决的都是批计算的问题，也称batch计算。离线计算需要把数据收集起来统一的去算，对于算法来讲，可能收敛会更快，因为参与计算的数据比较多。但是也有暴露一个问题，实时性很差。这个问题就引出了下一代计算引擎-流计算这样一个话题。</p><h2><a></a><a target=\"_blank\"></a>2. 流计算</h2><p>弄明白流计算，首先要搞清楚概念。先来看下流计算（stream compute）以及批计算（batch compute）的计算模型：</p><ul class=\" list-paddingleft-2\"><li><p>流计算：当一条数据被处理完成后,序列化到缓存中,然后立刻通过网络传输到下一个节点,由下一个节点继续处理。</p></li><li><p>批处理系统：当一条数据被处理完成后,序列化到缓存中,并不会立刻通过网络传输到下一个节点,当缓存写满,就持久化到本地硬盘上,当所有数据都被处理完成后,才开始将处理后的数据通过网络传输到下一个节点。</p></li></ul><p>对于流计算，是不是有一点感觉了。相较于batch compute，stream compute对于业务上一定是更灵活，因为可以跟数据更实时性的相关联（数据的时间周期其实很重要，有机会我也会给大家分享我的看法）。</p><p>stream对于业务的优势我举一个例子，比如一个电商平台，有一个推荐系统，推荐模型都是每周根据离线数据做批训练生成的。但是突然有一天，这个电商搞了一个针对特殊人群的定向营销活动，有大量的特殊用户涌入，那针对这部分人群以前的老模型可能就不会起作用，这时候如果有一个实时训练模型的能力就会对这种场景有更快速地响应，这个就有是online learning的概念，那底层依赖的是流计算引擎。</p><h2><a></a><a target=\"_blank\"></a>3. 真正的下一代流计算引擎</h2><p>流计算引擎会是下一代的计算引擎，这里指的不是流计算替代批计算，而是下一代流计算引擎会兼容batch compute和stream compute，做到流批一体，Flink或许是一个答案。</p><p>当然流计算的挑战会比做批计算大很多，比如failover机制，批计算所有计算结果都是有存储的，可以回溯，流计算怎么解决宕机问题。比如exactly once机制，如何保证分布式流计算中的数据只被处理一次，而不是被多台机器多次处理。</p><p>不过还是相信这些问题会被完美解决，未来的算法也一定是会向流式方向迁移。</p><h1><a></a><a target=\"_blank\"></a>二.浅谈FTRL算法（流式逻辑回归算法）</h1><h2><a></a><a target=\"_blank\"></a>1.流失算法概览</h2><p>先聊下对于流式算法的一些看法，流式算法就是要实时的去更新模型，所以从易实现的角度分析，不是所有的批计算算法都适合做流式算法，只有那些损失函数易于计算的算法才比较适合做成流式。</p><p>---------------------\r\n\r\n本文来自 李博Garvin 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/buptgshengod/article/details/82752207?utm_source=copy&nbsp;</p><p><br/></p>', '机器学习,算法,人工智能,流式计算', '机器学习', '原创', '云计算/大数据', '已发布', 'f7fc09d439f34fecaf747db52d7ba396', '2018年09月24日 14:42:38', '0', '0', 'yangming');
INSERT INTO `article` VALUES ('dfe2463e30d642c8a2114fea03f8dc82', 'Hadoop学习笔记(三) Ubuntu搭建Hadoop分布式集群', '<h1>运行环境</h1><p>因为是为了学习,且只有一台PC,只能在虚拟机里安装Hadoop</p><table><thead><tr class=\"firstRow\"><th>软件配置</th><th>版本</th></tr></thead><tbody><tr><td>主机</td><td>Win7,内存8G</td></tr><tr><td>虚拟机</td><td>VMware 14</td></tr><tr><td>Linux</td><td>ubuntu-14.04.5-desktop (使用ubuntu-18或16的话,电脑会比较卡)</td></tr><tr><td>Hadoop</td><td>2.9.1</td></tr><tr><td>JDK</td><td>1.8</td></tr></tbody></table><h1><a></a><a target=\"_blank\"></a>配置目标</h1><p>搭建一台NameNode名称为master，两台DataNode名称分别为node1和node2。</p><h1><a></a><a target=\"_blank\"></a>搭建Hadoop分布式集群步骤</h1><h2><a></a><a target=\"_blank\"></a>1 搭建master</h2><p>新建一个Ubuntu虚拟机,命名为ubuntu_14_master。<br/>如何在VMware里安装Ubuntu?，网上教程很多。</p><h3><a></a><a target=\"_blank\"></a>1.1 安装JDK</h3><p>安装JDK的步骤参考之前的博客<a href=\"https://blog.csdn.net/winterking3/article/details/82621894\" target=\"_blank\">Hadoop学习笔记(一) Ubuntu安装JDK和ssh</a></p><h3><a></a><a target=\"_blank\"></a>1.2 安装SSH</h3><p>SSH的工作原理自行百度吧</p><pre class=\"prettyprint\">#查看ssh的状态判断是否已经安装了ssh,如果返回ssh:&nbsp;unrecognized&nbsp;service,说明没有安装ssh\r\n$&nbsp;sudo&nbsp;service&nbsp;ssh&nbsp;status\r\n\r\n#或者如下命令查看是否有ssh的进程\r\n$&nbsp;sudo&nbsp;ps&nbsp;-e&nbsp;|&nbsp;grep&nbsp;ssh&nbsp;\r\n\r\n#如果没有安装ssh,输入如下2个命令安装\r\n#&nbsp;1.下载最新的软件列表\r\n$&nbsp;sudo&nbsp;apt-get&nbsp;update\r\n\r\n#&nbsp;2.Ubuntu缺省没有安装SSH&nbsp;Server,安装如下\r\n$&nbsp;sudo&nbsp;apt-get&nbsp;install&nbsp;openssh-server\r\n\r\n#如果ssh没有启动,输入下面命令启动\r\n$&nbsp;sudo&nbsp;service&nbsp;ssh&nbsp;start123456789101112131415</pre><p><span style=\"color:red\">这时暂不生成秘钥,等搭建好node后再生成</span></p><h3><a></a><a target=\"_blank\"></a>1.3 安装Hadoop</h3><p>安装Hadoop参考之前的博客<a href=\"https://blog.csdn.net/winterking3/article/details/82702227\" target=\"_blank\">Hadoop学习笔记(二) 安装Hadoop单节点集群</a><br/><span style=\"color:red\">但是只要操作到第2点配置.bashrc文件就行，第3点修改Hadoop配置文件的不用看</span></p><h2><a></a><a target=\"_blank\"></a>2 搭建node</h2><h3><a></a><a target=\"_blank\"></a>2.1 从master克隆出node</h3><p>把master虚拟机关机后,右击master,选择管理&gt;克隆,并在下一步后选择<span style=\"color:red\">完整克隆<br/><img src=\"https://img-blog.csdn.net/20180921141907531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbnRlcmtpbmcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"/><br/>克隆出2个node虚拟机,命名如下<br/><img src=\"https://img-blog.csdn.net/2018092114252174?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbnRlcmtpbmcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"在这里插入图片描述\"/></span></p><h3><a></a><a target=\"_blank\"></a>2.2 设置master和node之间SSH通信</h3><h4><a target=\"_blank\"></a>2.2.1 在master上修改hostsname</h4><pre class=\"prettyprint\">#在master上修改hostname,保存为master\r\nwinter@master:~$&nbsp;sudo&nbsp;gedit&nbsp;/etc/hostname</pre><p>---------------------\r\n\r\n本文来自 winterking3 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/winterking3/article/details/82784568?utm_source=copy&nbsp;</p><p><br/></p>', '大数据,Hadoop', '大数据', '原创', '云计算/大数据', '已发布', '1efda98d14bc4aa4bb54c38e450919bf', '2018年09月27日 16:40:33', '21', '3', 'jd530wd');
INSERT INTO `article` VALUES ('e0413a2bcccd4a8e8b9ed7e191b0082c', 'JavaScript常用方法总结', '<p>在web开发中，由于需要会涉及到一些js，自己记性不是很好，将自己在开发中经常用到的一些JS或是轮子总结一下。</p><h3><a></a>JS获取项目路径</h3><p>1.获取项目的绝对路径</p><pre class=\"has\">var&nbsp;local&nbsp;=&nbsp;window.location;var&nbsp;contextPath&nbsp;=&nbsp;local.pathname.split(&quot;/&quot;)[1];var&nbsp;basePath&nbsp;=&nbsp;local.protocol+&quot;//&quot;+local.host+&quot;/&quot;+contextPath;</pre><p>执行结果：</p><p><a href=\"http://localhost:8888/test\" target=\"_blank\">http://localhost:8080/test</a></p><p>2.获取项目的相对路径</p><pre class=\"has\">var&nbsp;pathName&nbsp;=&nbsp;document.location.pathname;var&nbsp;index&nbsp;=&nbsp;pathName.substr(1).indexOf(&quot;/&quot;);var&nbsp;basePath=&nbsp;pathName.substr(0,index+1);</pre><p>执行结果：</p><p>pathName===/test/index.jsp<br/>basePath===/test</p><p>第二种方式加载更快</p><h3><a></a>基于Jquery的Ajax交互</h3><p>1.常规方式调用ajax</p><pre class=\"has\">$.ajax({type:&nbsp;&quot;POST&quot;,dataType:&quot;JSON&quot;,async:false,url:&nbsp;basePath+&#39;/book/mApply.do?&#39;,data:{&quot;bookId&quot;:bookId},success:&nbsp;function(result){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	if(result.success){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		$(&quot;#applyBorrow1&quot;).innerHTML=&quot;已申请&quot;;	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		$(&quot;#bookHadNow&quot;).innerHTML=&quot;库存：&quot;+(bookHadNow-1)+&quot;&lt;br&gt;&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		$(&quot;#applyBorrow1&quot;).disabled=true;				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		var&nbsp;btn1&nbsp;=&nbsp;[&#39;确定&#39;];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		mui.alert(&#39;该书无库存，申请失败&#39;,&nbsp;&#39;&#39;,&nbsp;btn1,&nbsp;function(e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		window.location.reload();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;		});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;	}}})</pre><p>2.文件上传ajax(注意与第一种方法参数的区别)</p><p><br/></p><p><br/></p>', '前端,JavaScript,浏览器', '前端', '原创', '前端', '已发布', 'f7fc09d439f34fecaf747db52d7ba396', '2018年09月27日 08:27:31', '4', '0', 'yangming');
INSERT INTO `article` VALUES ('ea608d8dca314e02948bb3055921e7f3', 'Android逆向之旅---抖音火山视频的Native注册混淆函数获取方法', '<h3>一、静态分析</h3><p>最近在小密圈中有很多同学都在咨询有时候有些应用的动态注册Native函数，在分析so之后发现找不到真的实现函数功能地方，我们知道有时候为了安全考虑会动态注册Native函数，但是如果只是这么做的话就会非常简单，比如这样的：</p><p><img alt=\"\" class=\"has\" src=\"https://fourbrother-img-1252178963.cos.ap-beijing.myqcloud.com/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%A7%A3%E5%AF%86so%E7%AE%97%E6%B3%95/05.png\"/></p><p>这样的我们熟知ReigsterNatives函数的参数结构立马就可以获取到Native的实现逻辑函数功能了，所以有的应用为了安全就把这些信息加密或者混淆了，而无意中发现了抖音火山的so就是这么做的，我们用IDA打开他的so文件：</p><p><img alt=\"\" class=\"has\" src=\"https://fourbrother-img-1252178963.cos.ap-beijing.myqcloud.com/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E6%8A%96%E9%9F%B3Native%E6%96%B9%E6%B3%95%E6%B7%B7%E6%B7%86%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/01.png\"/></p><p>直接找到JNI_OnLoad函数发现他用了OLLVM混淆啥的，先不管这些了，往下看找到RegisterNatives：</p><p><img alt=\"\" class=\"has\" src=\"https://fourbrother-img-1252178963.cos.ap-beijing.myqcloud.com/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E6%8A%96%E9%9F%B3Native%E6%96%B9%E6%B3%95%E6%B7%B7%E6%B7%86%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/02.png\"/></p><p>这里大家如果看到类似于vXX+YYY这样的，选中vXX变量，然后按Y按键，然后替换成JNIEnv*即可，我们如果手动注册过Native方法，都知道RegisterNatives函数的三个参数含义：</p><p><span style=\"color:#f33b45;\"><strong>jint RegisterNatives(jclass clazz, const JNINativeMethod* methods, jint nMethods)</strong></span></p><p><strong>第一个参数：需要注册native函数的上层Java类</strong></p><p><strong>第二个参数：注册的方法结构体信息</strong></p><p><strong>第三个参数：需要注册的方法个数</strong></p><p>这里当然是重点看第二个参数，这里当然也需要知道方法结构体信息：</p><p><span style=\"color:#f33b45;\"><strong>typedef struct {<br/>&nbsp; &nbsp; const char* name;<br/>&nbsp; &nbsp; const char* signature;<br/>&nbsp; &nbsp; void* &nbsp; &nbsp; &nbsp; fnPtr;<br/>} JNINativeMethod;</strong></span></p><p>结构体包含三部分分别是：方法名、方法的签名、对应的native函数地址；那么这里我们肯定重点看第三部分，因为要找到具体的解密函数，这时候我们需要去对RegisterNatives函数查看他的实参值：</p><p><img alt=\"\" class=\"has\" src=\"https://fourbrother-img-1252178963.cos.ap-beijing.myqcloud.com/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E6%8A%96%E9%9F%B3Native%E6%96%B9%E6%B3%95%E6%B7%B7%E6%B7%86%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/03.png\"/></p><p>然后就可以看到具体参数值了：</p><p><img alt=\"\" class=\"has\" src=\"https://fourbrother-img-1252178963.cos.ap-beijing.myqcloud.com/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E6%8A%96%E9%9F%B3Native%E6%96%B9%E6%B3%95%E6%B7%B7%E6%B7%86%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/04.png\"/></p><p>点击第三个参数查看注册方法体信息：</p><p><img alt=\"\" class=\"has\" src=\"https://fourbrother-img-1252178963.cos.ap-beijing.myqcloud.com/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E6%8A%96%E9%9F%B3Native%E6%96%B9%E6%B3%95%E6%B7%B7%E6%B7%86%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/05.png\"/></p><p>可惜这里的数据被加密或者混淆了，而且我们点击函数地址发现也都是常量数据了。</p><p>---------------------\r\n\r\n本文来自 尼古拉斯_赵四 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/jiangwei0910410003/article/details/82822483?utm_source=copy&nbsp;</p><p><br/></p>', 'Android', 'Android,Java', '翻译', '后端', '回收', 'f7fc09d439f34fecaf747db52d7ba396', '2018年09月24日 14:40:03', '1', '0', 'yangming');
INSERT INTO `article` VALUES ('ed1d942f5c23428e82c0044272c67765', '如何玩转微服务', '<h3>微服务，软件应用开发的新纪元</h3><p>2014年 Martin Fowler 在《MicroServices》论文中首次提出了微服务的概念。近些年，伴随着互联网的日益发展，微服务在国内、甚至国际上的发展已达到一个新高潮。</p><p>在微服务流行之前，SOA（Service Oriented Architecture）被广泛熟知与采用。微服务基于 SOA 发展而来，但与之相比，微服务更易于理解，也更利于设计者、开发者的实践落地，它把“面向服务”的设计思想实现得更加彻底。</p><h3><a></a>微服务架构模式的优势与痛点</h3><p>微服务架构建议实践者以“业务”来切分服务，鼓励开发者选择最适合的技术实现具体的服务，只需保证其对外提供的 API 接口保持一致即可。也就是说，微服务架构理念的出现，使得应用开发前的技术选型的选择空间更加宽广、灵活。</p><p>将系统拆分为多个微服务，也便于对每个微服务分别实施监控，不断收集每个微服务的具体指标。当某个微服务出现性能瓶颈时，可针对性的对该服务进行水平扩展以支撑当前大流量，而无需对整个系统进行横向扩展。</p><p>除了以上优点，微服务架构按业务拆分服务的理念，更使服务之间彼此隔离，相互之间不会产生影响。这也便于我们在开发过程中利用技术手段，更高效地实现自动化部署。</p><p>正因为这些优点，当前很多软件企业在开发新项目时，首先考虑的是微服务架构，甚至企业正将以前的老系统慢慢迭代为该架构模式。</p><p>当然，除了以上优点，微服务架构也存在以下缺点：</p><ol class=\" list-paddingleft-2\"><li><p>微服务粒度大小难以划分，需要设计人员对业务有很好的掌握；</p></li><li><p>分布式复杂性，主要体现在分布式事务、网络延迟、系统容错等问题解决难度较大；</p></li><li><p>微服务之间通信成本较高，对微服务之间网络稳定性，通信速度要求较高；</p></li><li><p>微服务数量较大，对运维人员的运维、部署工作带来较大的挑战。</p></li></ol><h3><a></a>微服务开发踩坑经验</h3><p>经过多年来不断的探索与总结，在微服务设计、开发领域，我已积累了丰富的实战经验，深知微服务实践过程中各个痛点及难点。</p><p>避免大家再踩我之前所趟过的坑，让开发过程更加顺利、更专注于业务开发，我特别推出了我的达人课《微服务一站式开发》，它集合了自己在微服务开发过程中的所有经验总结，主要包括以下主要内容：</p><ol class=\" list-paddingleft-2\"><li><p>目前，微服务开发中，各大公司通常采用的技术主要有 Spring Boot、Spring Cloud，因此在课程的开篇首先会对 Spring Boot 的基础知识，以及它与其他常用的各大技术框架的整合进行演示，并带大家利用 Spring Cloud 整合 Consul 实现服务的注册、发现等；</p></li><li><p>微服务调用过程中，遇到网络等不稳定因素时，如果不加以控制，系统很容易发生雪崩效应。本课程将充分利用 Spring Cloud 相关特性教各位读者如何实现服务的熔断、降级、限流等功能，从而解决这一问题；</p></li><li><p>将整个系统按业务拆分成多个服务，这个过程需要解决微服务鉴权、分布式事务、分布式锁等关键问题。为此，本课程引入了 Spring Cloud Zuul 对微服务进行统一鉴权的讲解；对 Redis、Zookeeper 高级技术点的解读，及利用它们如何实现分布式锁的过程分析；对分布式事务的理论说明，以及消息中间件 RabbitMQ 之死信队列、发布确认、消费确认的应用指南，并利用它们实现数据的最终一致性，解决微服务分布式事务；还会讲解如何利用第三方开源框架实现数据的实时一致性等内容；</p></li><li><p>微服务的数量往往较大，运维人员面临着运维、部署困难等问题，为此课程为各位读者带来了微服务监控、Docker 的常用命令、架构以及容器管理平台 Rancher、K8S 等相关技术使用指南；</p></li><li><p>最后，课程将通过一个完整的项目，带大家了解微服务从开发，到代码提交，再到打镜像、自动拉起容器、容器的扩缩容等一系列完整的过程，并对其中使用到的关键技术和工具（如 Jenkins）一一进行精要说明。</p></li></ol><p>为了方便大家更清晰地学习本课程，我们再来看下课程目录安排。</p><ul class=\" list-paddingleft-2\"><li><p>第01-02课：主要演示微服务开发过程中，Spring、Spring MVC 常用主要知识点；</p></li><li><p>第03-05课：主要演示在实际工作中，Spring Boot 如何整合诸如 Spring Data JPA、Redis、MongoDB、RabbitMQ、Elasticsearch 此类的常用技术； <br/>第06-09课：将对 Consul 相关知识做详解，并利用 Spring Cloud 和 Consul 实现服务的注册与发现；同时将演示 Spring Cloud常用组件（如 Zuul、Ribbon、Hystrix、Feign 等）在实际工作中使用方法；此外，在网关层整合 OAuth 2 实现微服务鉴权、配置中心及请求链路跟踪等内容也会在本部分进行详细解读与演示；</p></li><li><p>第10-13课：首先会对 Redis 分片原理、集群搭建、分片数据迁移，Redis 与 Lua 脚本整合进行详解；接着，对 ZooKeeper 相关算法（如 Paxos、ZAB）进行介绍，并对其 watcher 的实现原理及 ZooKeeper 集群搭建过程作分析与说明；之后讲解如何利用 Redis、DB、ZooKeeper 等实现分布式锁，介绍分布式事务相关原理，并演示在工作中如何利用消息中间件实现数据最终一致性和利用第三方组件实现数据实时一致性等内容；</p></li><li><p>第14课：主要演示如何实现微服务监控；</p></li><li><p>第15-17课：介绍 Docker 架构及常用命令；对常用容器管理平台如 Rancher、K8S 进行详细说明，并说明工作中如何用其管理容器；</p></li><li><p>第18课：实战部分，对前17课所讲内容进行综合实战，让读者了解在工作中如何应用以上技术。其中主要包括微服务开发、微服务网关、微服务调用、负载均衡、熔断、微服务鉴权、日志监控、配置中心、微服务镜像生成、容器管理平台搭建及如何管理容器等技术内容。</p></li></ul><p><br/></p><p><br/></p>', '微服务,架构', '微服务', '原创', '云计算/大数据', '已发布', 'a3c904ef7cc44272adfb49094a5822a4', '2018年09月24日 14:43:59', '0', '0', 'wolaile');
INSERT INTO `article` VALUES ('fafe93ce6b694cd0b5812bdf824d3bc5', 'SSD算法代码介绍（一）：训练参数配置', '<p>SSD算法是object detection领域比较经典的算法，github上有一个写得比较好的MXNet版本的实现代码，项目地址：https://github.com/zhreshold/mxnet-ssd，目前该项目代码也已经并入MXNet官方github。想要本地实现可以参考项目地址中README.md的介绍或者参考博客：SSD算法的MXNet实现。</p><p><br/></p><p>接下来这一系列博客想介绍该代码中关于实现SSD算法的一些细节，也会涉及部分Python语言的巧妙代码，以训练模型为切入口展开介绍，最好按顺序阅读，详细注释已经在代码中给出。</p><p><br/></p><p>这一篇博客介绍训练模型的入口代码：train.py脚本，该脚本主要包含一些参数设置和主函数。</p><p><br/></p><p><br/></p><p><br/></p><p>import argparse</p><p>import tools.find_mxnet</p><p>import mxnet as mx</p><p>import os</p><p>import sys</p><p>from train.train_net import train_net</p><p><br/></p><p>def parse_args():</p><p>&nbsp; &nbsp; parser = argparse.ArgumentParser(description=&#39;Train a Single-shot detection network&#39;)</p><p>&nbsp; &nbsp; parser.add_argument(&#39;--train-path&#39;, dest=&#39;train_path&#39;, help=&#39;train record to use&#39;,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default=os.path.join(os.getcwd(), &#39;data&#39;, &#39;train.rec&#39;), type=str)</p><p>&nbsp; &nbsp; parser.add_argument(&#39;--train-list&#39;, dest=&#39;train_list&#39;, help=&#39;train list to use&#39;,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default=&quot;&quot;, type=str)</p><p>&nbsp; &nbsp; parser.add_argument(&#39;--val-path&#39;, dest=&#39;val_path&#39;, help=&#39;validation record to use&#39;,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default=os.path.join(os.getcwd(), &#39;data&#39;, &#39;val.rec&#39;), type=str)</p><p>&nbsp; &nbsp; parser.add_argument(&#39;--val-list&#39;, dest=&#39;val_list&#39;, help=&#39;validation list to use&#39;,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default=&quot;&quot;, type=str)</p><p>&nbsp; &nbsp; parser.add_argument(&#39;--network&#39;, dest=&#39;network&#39;, ty</p><p><br/></p><p>---------------------</p><p><br/></p><p>本文来自 AI之路 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/u014380165/article/details/79332339?utm_source=copy&nbsp;</p><p><br/></p>', '编程 ,语言', '', '转载', '编程语言', '回收', '71214c5d9cff4d4bb2bf06615788d005', '2018年09月24日 15:03:30', '0', '0', 'TANG');

-- ----------------------------
-- Table structure for attention
-- ----------------------------
DROP TABLE IF EXISTS `attention`;
CREATE TABLE `attention` (
  `focus_id` char(32) NOT NULL,
  `focus` char(32) NOT NULL,
  `befocus` char(32) NOT NULL,
  PRIMARY KEY (`focus_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of attention
-- ----------------------------
INSERT INTO `attention` VALUES ('3e424c7846bb4aba8dec03572b58eca6', '1efda98d14bc4aa4bb54c38e450919bf', 'a3c904ef7cc44272adfb49094a5822a4');
INSERT INTO `attention` VALUES ('4460550809cb43ba82625f882b5295ba', '', '1efda98d14bc4aa4bb54c38e450919bf');
INSERT INTO `attention` VALUES ('765743fe64e14c28be627a188b7eb0ee', 'f7fc09d439f34fecaf747db52d7ba396', '1efda98d14bc4aa4bb54c38e450919bf');
INSERT INTO `attention` VALUES ('8763a8d0e73441549f02765ba45539c1', 'f7fc09d439f34fecaf747db52d7ba396', 'a3c904ef7cc44272adfb49094a5822a4');
INSERT INTO `attention` VALUES ('8775273bb41844df977c44f186cdbd45', 'a1097602c3174132952e56ef8840d7cb', 'a3c904ef7cc44272adfb49094a5822a4');
INSERT INTO `attention` VALUES ('b01d32d5b91648889015e9fe642504d1', '1efda98d14bc4aa4bb54c38e450919bf', 'f7fc09d439f34fecaf747db52d7ba396');
INSERT INTO `attention` VALUES ('fcc2b347a8384a23ad230f9a0248cb12', 'a3c904ef7cc44272adfb49094a5822a4', 'a1097602c3174132952e56ef8840d7cb');

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `cid` char(32) NOT NULL,
  `aid` char(32) DEFAULT NULL,
  `uid` char(32) DEFAULT NULL,
  `account` tinytext NOT NULL,
  `comment_time` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`cid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES ('0de4b2d31a394d88b9721ac71881223d', '1e3447634da04baabdd972ac5f9e879d', '71214c5d9cff4d4bb2bf06615788d005', '好哦，博主厉害啊，赞一个', '2018年09月26日 15:20:45');
INSERT INTO `comment` VALUES ('0e2ac410615b43e0a22d15c248a2fdd6', '1e3447634da04baabdd972ac5f9e879d', 'f7fc09d439f34fecaf747db52d7ba396', '6666666666666666666666666', '2018年09月26日 16:41:23');
INSERT INTO `comment` VALUES ('481427a57c0b4c0a94052be68d4ade35', '1e3447634da04baabdd972ac5f9e879d', 'f7fc09d439f34fecaf747db52d7ba396', '666', '2018年09月26日 16:41:51');
INSERT INTO `comment` VALUES ('4c02cbe2916c40bba9906a1264df4eea', '1e3447634da04baabdd972ac5f9e879d', 'a1097602c3174132952e56ef8840d7cb', '参数那里有点问题吧', '2018年09月26日 15:21:51');
INSERT INTO `comment` VALUES ('6de782d785524ad9b86e14f378beb065', '1e3447634da04baabdd972ac5f9e879d', 'f7fc09d439f34fecaf747db52d7ba396', '说的都是错的，老哥', '2018年09月26日 15:56:02');
INSERT INTO `comment` VALUES ('806e3c4103ad4036bcb438b31606a0ad', '8ae77b47b45045d49246e085cabf4f91', 'f7fc09d439f34fecaf747db52d7ba396', '哇咔咔', '2018年09月27日 11:35:44');
INSERT INTO `comment` VALUES ('8ca832add4714c7eaf187df4e4f11ec1', '3f2b71ac50a049dda7513248c6a3ed59', 'f7fc09d439f34fecaf747db52d7ba396', '666啊', '2018年09月26日 16:42:24');
INSERT INTO `comment` VALUES ('97c6a7bb769f4d2d90cc7a8c2865fe5b', 'dfe2463e30d642c8a2114fea03f8dc82', '1efda98d14bc4aa4bb54c38e450919bf', '收藏不看系列', '2018年09月27日 16:41:36');
INSERT INTO `comment` VALUES ('9b9dbc2edec24fb18d75f99c3c78d51f', '1e3447634da04baabdd972ac5f9e879d', 'f7fc09d439f34fecaf747db52d7ba396', '欢迎大家提出宝贵意见', '2018年09月26日 15:13:00');
INSERT INTO `comment` VALUES ('a8b8fb4daf7b47c7aa83c3b4d99b275a', 'ca86ad81397a4a5f9e5bfd4f14452463', 'f7fc09d439f34fecaf747db52d7ba396', '666', '2018年09月27日 15:13:14');
INSERT INTO `comment` VALUES ('ab7fdd1de912498dbb1a27c927f1a9a1', 'dfe2463e30d642c8a2114fea03f8dc82', '1efda98d14bc4aa4bb54c38e450919bf', '博主666，收藏了', '2018年09月27日 16:41:27');
INSERT INTO `comment` VALUES ('afadb447034f42e1812e946a54b7edee', '1e3447634da04baabdd972ac5f9e879d', 'f7fc09d439f34fecaf747db52d7ba396', '6666', '2018年09月26日 16:41:32');
INSERT INTO `comment` VALUES ('bd0d740881414d6eadd3a0ec2be4aacb', '1e3447634da04baabdd972ac5f9e879d', 'a3c904ef7cc44272adfb49094a5822a4', '赞赞赞', '2018年09月26日 15:19:44');
INSERT INTO `comment` VALUES ('c4e8214a2f7147139c14f8ed150f5b87', '4611b84ce25544f6882d2249b27ad655', 'f7fc09d439f34fecaf747db52d7ba396', '兄弟，你太年轻了', '2018年09月26日 15:58:28');
INSERT INTO `comment` VALUES ('c9a8639af97b44be9b36fe5e065ac7bc', 'dfe2463e30d642c8a2114fea03f8dc82', 'f7fc09d439f34fecaf747db52d7ba396', '666', '2018年09月28日 10:13:41');
INSERT INTO `comment` VALUES ('caefff96f6e04d40862f3266b560046c', '8ae77b47b45045d49246e085cabf4f91', 'f7fc09d439f34fecaf747db52d7ba396', '666', '2018年09月27日 15:13:37');
INSERT INTO `comment` VALUES ('d0ae274983cc4143b0136788521beecf', '1e3447634da04baabdd972ac5f9e879d', 'f7fc09d439f34fecaf747db52d7ba396', '牛逼，顶你的个肺', '2018年09月26日 15:57:08');
INSERT INTO `comment` VALUES ('d4cdafdb61fb45df82021a5aee222fb8', '1e3447634da04baabdd972ac5f9e879d', 'f7fc09d439f34fecaf747db52d7ba396', '6666', '2018年09月26日 15:57:23');
INSERT INTO `comment` VALUES ('e12618c8d31a42368adb936f375a3ea8', '1e3447634da04baabdd972ac5f9e879d', 'a3c904ef7cc44272adfb49094a5822a4', '不错，这边Android的文章写的很好，感谢博主', '2018年09月26日 15:19:26');
INSERT INTO `comment` VALUES ('e2d8e27fcc6a450c9515d00232e79d14', '1e3447634da04baabdd972ac5f9e879d', 'f7fc09d439f34fecaf747db52d7ba396', '123', '2018年09月27日 14:35:49');
INSERT INTO `comment` VALUES ('ee231a1b48bd4dceacb660a6cdffb2ce', '1e3447634da04baabdd972ac5f9e879d', 'f7fc09d439f34fecaf747db52d7ba396', '666', '2018年09月26日 15:57:43');
INSERT INTO `comment` VALUES ('f5b6bbbe5da94f2da220c721065686dd', '1e3447634da04baabdd972ac5f9e879d', 'f7fc09d439f34fecaf747db52d7ba396', '77777777', '2018年09月26日 15:57:57');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `uid` char(32) NOT NULL,
  `username` varchar(30) NOT NULL,
  `password` varchar(30) NOT NULL,
  `email` varchar(30) DEFAULT NULL,
  `phone` char(11) DEFAULT NULL,
  `birthday` varchar(20) DEFAULT NULL,
  `image` varchar(50) DEFAULT NULL,
  `truename` varchar(20) DEFAULT NULL,
  `sex` varchar(20) DEFAULT NULL,
  `location` varchar(50) DEFAULT NULL,
  `job` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`uid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('1efda98d14bc4aa4bb54c38e450919bf', 'jd530wd', '123456abc', 'tjpshar96@aliyun.com', '15971017637', '2018-09-03', '1efda98d14bc4aa4bb54c38e450919bf-head.png', '交大南区最强妖姬', '女', '交大南区530', '交大以南地区最强妖姬');
INSERT INTO `user` VALUES ('71214c5d9cff4d4bb2bf06615788d005', 'TANG', '123456ABC', '844190140@qq.com', '13155818618', '2018-05-08', '71214c5d9cff4d4bb2bf06615788d005-head.png', 'TANG', '女', '江西南昌', 'java工程师');
INSERT INTO `user` VALUES ('a1097602c3174132952e56ef8840d7cb', 'YANG', '123456ABC', '742777@3wcc.om', '13145355334', '2018-09-13', 'a1097602c3174132952e56ef8840d7cb-head.png', 'YANG', '女', '江西南昌', 'java工程师');
INSERT INTO `user` VALUES ('a3c904ef7cc44272adfb49094a5822a4', 'wolaile', '123456abc', 'tjpshar96@163.com', '13657007044', '2018-01-01', 'a3c904ef7cc44272adfb49094a5822a4-head.png', '汤俊鹏', '男', '江西省南昌市华东交大南区信息学院', '程序员');
INSERT INTO `user` VALUES ('f7fc09d439f34fecaf747db52d7ba396', 'yangming', '123456abc', '123@163.com', '13657080040', '1996-09-01', 'f7fc09d439f34fecaf747db52d7ba396-head.png', '杨明123', '男', '江西省南昌市交大南区9栋最热的寝室', '美工做PPT');
